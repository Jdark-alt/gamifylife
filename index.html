<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LevelUp - Life Gamification</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg-primary: #1a1a1a;
            --color-bg-secondary: #2a2a2a;
            --color-bg-card: #2d2d2d;
            --color-text-primary: #ffffff;
            --color-text-secondary: #b0b0b0;
            --color-accent-blue: #4a7c9e;
            --color-accent-red: #8e3b5f;
            --color-accent-green: #6b7c3f;
            --color-accent-olive: #7a7b4d;
            --color-progress: #5a9fd4;
            --color-border: #3a3a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--color-bg-primary);
            color: var(--color-text-primary);
            line-height: 1.6;
        }

        /* ── Auth Screen ─────────────────────────────────────────────────── */
        .auth-container {
            display: flex;
            min-height: 100vh;
            background: var(--color-bg-primary);
            position: relative;
            overflow: hidden;
        }

        /* Ambient glow blobs behind the card */
        .auth-container::before {
            content: '';
            position: absolute;
            top: -20%;
            left: -10%;
            width: 60%;
            height: 60%;
            background: radial-gradient(ellipse, rgba(74,124,158,0.18) 0%, transparent 70%);
            pointer-events: none;
        }
        .auth-container::after {
            content: '';
            position: absolute;
            bottom: -15%;
            right: -10%;
            width: 55%;
            height: 55%;
            background: radial-gradient(ellipse, rgba(142,59,95,0.14) 0%, transparent 70%);
            pointer-events: none;
        }

        .auth-panel {
            margin: auto;
            width: 100%;
            max-width: 420px;
            padding: 24px 20px;
            position: relative;
            z-index: 1;
        }

        .auth-brand {
            text-align: center;
            margin-bottom: 36px;
        }

        .auth-brand-icon {
            font-size: 48px;
            line-height: 1;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 20px rgba(90,159,212,0.5));
        }

        .auth-brand-name {
            font-size: 28px;
            font-weight: 800;
            letter-spacing: -1px;
            background: linear-gradient(135deg, #ffffff 30%, var(--color-progress));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .auth-brand-tagline {
            font-size: 13px;
            color: var(--color-text-secondary);
            margin-top: 4px;
            letter-spacing: 0.02em;
        }

        .auth-card {
            background: rgba(36,36,42,0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255,255,255,0.07);
            border-radius: 20px;
            padding: 32px 28px;
            box-shadow: 0 24px 64px rgba(0,0,0,0.5);
        }

        .auth-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            background: rgba(0,0,0,0.25);
            padding: 4px;
            border-radius: 10px;
        }

        .auth-tab {
            flex: 1;
            padding: 9px 12px;
            background: transparent;
            border: none;
            color: var(--color-text-secondary);
            border-radius: 7px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            font-family: inherit;
            letter-spacing: 0.01em;
        }

        .auth-tab.active {
            background: var(--color-accent-blue);
            color: #fff;
            box-shadow: 0 2px 8px rgba(74,124,158,0.4);
        }

        .auth-form { display: none; }
        .auth-form.active { display: block; }

        .auth-field {
            margin-bottom: 14px;
        }

        .auth-field label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .auth-field input {
            width: 100%;
            padding: 11px 14px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            color: var(--color-text-primary);
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .auth-field input:focus {
            outline: none;
            border-color: var(--color-accent-blue);
            box-shadow: 0 0 0 3px rgba(74,124,158,0.2);
        }

        .auth-field input::placeholder { color: rgba(255,255,255,0.2); }

        .btn-auth {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--color-accent-blue), var(--color-progress));
            color: #fff;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            letter-spacing: 0.02em;
            box-shadow: 0 4px 16px rgba(74,124,158,0.35);
            margin-top: 6px;
        }

        .btn-auth:hover { opacity: 0.9; transform: translateY(-1px); box-shadow: 0 6px 20px rgba(74,124,158,0.45); }
        .btn-auth:active { transform: translateY(0); }
        .btn-auth:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .auth-divider {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 20px 0;
            color: rgba(255,255,255,0.2);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.08em;
        }

        .auth-divider::before, .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.08);
        }

        .btn-google {
            width: 100%;
            padding: 11px 16px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            color: var(--color-text-primary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn-google:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.2); }
        .btn-google:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-google-spinner {
            width: 16px; height: 16px;
            border: 2px solid rgba(255,255,255,0.2);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
            display: none;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .error-message {
            background: rgba(142,59,95,0.15);
            border: 1px solid rgba(142,59,95,0.4);
            color: #e07070;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 16px;
            display: none;
        }

        .error-message {
            background: rgba(220, 53, 69, 0.1);
            border: 1px solid rgba(220, 53, 69, 0.3);
            color: #ff6b6b;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
        }

        /* Main App */
        .app-container {
            display: none;
        }

        .app-container.active {
            display: block;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 3px;
            background: var(--color-bg-secondary);
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .nav-tab {
            flex: 1;
            padding: 9px 6px;
            background: transparent;
            border: none;
            color: var(--color-text-secondary);
            border-radius: 7px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.18s;
            text-align: center;
            font-family: inherit;
            white-space: nowrap;
            letter-spacing: -0.01em;
        }

        .nav-tab.active {
            background: var(--color-accent-blue);
            color: #fff;
            font-weight: 600;
        }

        .nav-tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.05);
            color: var(--color-text-primary);
        }

        /* Mobile: fixed bottom tab bar */
        @media (max-width: 640px) {
            .nav-tabs {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 200;
                margin: 0;
                border-radius: 0;
                border-top: 1px solid var(--color-border);
                padding: 6px 8px calc(6px + env(safe-area-inset-bottom));
                background: var(--color-bg-secondary);
                box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
                gap: 2px;
            }

            .nav-tab {
                flex: 1;
                padding: 8px 2px;
                font-size: 10px;
                border-radius: 6px;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 3px;
                font-weight: 500;
            }

            .nav-tab::before {
                content: attr(data-icon);
                font-size: 18px;
                line-height: 1;
                display: block;
            }

            .nav-tab.active {
                background: rgba(74,124,158,0.18);
                color: var(--color-progress);
            }

            /* Push main content up so bottom nav doesn't cover it */
            .main-content {
                padding-bottom: 90px !important;
            }
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Sticky Header */
        .sticky-header {
            position: sticky;
            top: 0;
            background: var(--color-bg-secondary);
            border-bottom: 1px solid var(--color-border);
            z-index: 100;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px 24px;
        }

        .header-top {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        /* ── LEFT: LEVEL badge ── */
        .level-badge {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-shrink: 0;
            gap: 0;
        }

        .level-label {
            font-size: 8px;
            font-weight: 700;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--color-text-secondary);
            line-height: 1;
            margin-bottom: 1px;
        }

        .level-display {
            font-size: 52px;
            font-weight: 800;
            letter-spacing: -2px;
            line-height: 0.9;
            background: linear-gradient(135deg, var(--color-text-primary) 30%, var(--color-progress));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex-shrink: 0;
        }

        /* ── CENTER: XP label row + progress bar (stretches between level and sign-out) ── */
        .progress-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        /* Above-bar row: XP on left, pct + xp-to-next on right */
        .progress-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-xp-current {
            font-size: 19px;
            font-weight: 700;
            letter-spacing: -0.03em;
            line-height: 1;
            /* Matching gradient: accent-blue → progress (same as level number and bar) */
            background: linear-gradient(135deg, var(--color-accent-blue) 0%, var(--color-progress) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-xp-label {
            font-size: 9px;
            font-weight: 600;
            color: var(--color-text-secondary);
            letter-spacing: 0.06em;
            text-transform: uppercase;
            margin-left: 3px;
        }

        /* Right side of above-bar row */
        .header-meta-right {
            display: flex;
            align-items: baseline;
            gap: 0;
            font-size: 11px;
            font-weight: 400;
            color: var(--color-text-secondary);
            white-space: nowrap;
        }

        .header-meta-pct {
            font-weight: 500;
            color: var(--color-text-secondary);
        }

        .header-meta-sep {
            margin: 0 4px;
            opacity: 0.4;
        }

        .header-meta-xp-left {
            color: #6dbf7e;
            font-weight: 600;
        }

        .progress-bar-container {
            width: 100%;
            height: 11px;
            background: rgba(255,255,255,0.07);
            border-radius: 99px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            max-width: 100%;
            background: linear-gradient(90deg, var(--color-accent-blue), var(--color-progress));
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 99px;
            position: relative;
            min-width: 0;
        }

        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 60%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.25), transparent);
            animation: shimmer 2.5s ease-in-out infinite;
            border-radius: 99px;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            width: 28px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.45));
            border-radius: 0 99px 99px 0;
        }

        @keyframes shimmer {
            0%   { left: -100%; opacity: 0; }
            20%  { opacity: 1; }
            80%  { opacity: 1; }
            100% { left: 200%; opacity: 0; }
        }

        .user-info {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .user-email {
            color: var(--color-text-secondary);
            font-size: 12px;
            font-weight: 400;
            max-width: 160px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .btn-logout {
            padding: 6px 12px;
            background: transparent;
            color: var(--color-text-secondary);
            border: 1px solid var(--color-border);
            border-radius: 7px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            white-space: nowrap;
        }

        .btn-logout:hover {
            background: rgba(142,59,95,0.15);
            border-color: var(--color-accent-red);
            color: #e07070;
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 20px;
        }

        .welcome-section {
            text-align: center;
            padding: 60px 20px;
        }

        .welcome-section h2 {
            font-size: 36px;
            margin-bottom: 12px;
        }

        .welcome-section p {
            color: var(--color-text-secondary);
            font-size: 18px;
            margin-bottom: 24px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 32px;
        }

        .stat-card {
            background: var(--color-bg-card);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--color-border);
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 1px;
        }

        .stat-label {
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        .stat-card.blue {
            background: linear-gradient(135deg, var(--color-accent-blue) 0%, rgba(74, 124, 158, 0.3) 100%);
        }

        .stat-card.red {
            background: linear-gradient(135deg, var(--color-accent-red) 0%, rgba(142, 59, 95, 0.3) 100%);
        }

        .stat-card.green {
            background: linear-gradient(135deg, var(--color-accent-green) 0%, rgba(107, 124, 63, 0.3) 100%);
        }

        .cta-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 13px 28px;
            background: linear-gradient(135deg, var(--color-accent-blue), var(--color-progress));
            color: #fff;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            letter-spacing: -0.01em;
            box-shadow: 0 4px 16px rgba(74,124,158,0.35);
        }

        .cta-button:hover {
            opacity: 0.92;
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(74,124,158,0.45);
        }
        
        .cta-button:active {
            transform: translateY(0);
        }

        /* Loading Spinner */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--color-bg-secondary);
            border-top: 4px solid var(--color-accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Confetti Animation */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--color-accent-blue);
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Activity Management */
        .activity-section {
            margin-top: 32px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 24px;
            font-weight: 600;
        }

        .btn-add {
            padding: 10px 20px;
            background: var(--color-accent-blue);
            color: var(--color-text-primary);
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-add:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* Filter button */
        .btn-filter {
            position: relative;
            padding: 8px 10px;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            color: var(--color-text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: all 0.15s;
        }

        .btn-filter:hover, .btn-filter.active {
            border-color: var(--color-accent-blue);
            color: var(--color-accent-blue);
        }

        .filter-panel {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            min-width: 200px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            z-index: 200;
            overflow: hidden;
        }

        .filter-panel-title {
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--color-text-secondary);
            padding: 10px 14px 6px;
        }

        .filter-options {
            display: flex;
            flex-direction: column;
        }

        .filter-option {
            padding: 9px 14px;
            font-size: 13px;
            font-weight: 500;
            color: var(--color-text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
            border: none;
            background: none;
            text-align: left;
            width: 100%;
        }

        .filter-option:hover {
            background: rgba(255,255,255,0.05);
        }

        .filter-option.selected {
            color: var(--color-accent-blue);
            background: rgba(68,114,160,0.1);
        }

        .filter-option .fo-icon {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }

        .filter-panel-footer {
            border-top: 1px solid var(--color-border);
            padding: 8px 10px;
        }

        .btn-filter-default {
            width: 100%;
            padding: 6px 10px;
            background: rgba(68,114,160,0.12);
            border: 1px solid rgba(68,114,160,0.25);
            border-radius: 6px;
            color: var(--color-accent-blue);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-filter-default:hover {
            background: rgba(68,114,160,0.22);
        }

        /* Dimension Card */
        .dimension-card {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            margin-bottom: 14px;
        }

        .dimension-header {
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.18s;
            user-select: none;
            -webkit-user-select: none;
        }

        .dimension-header:hover {
            background: rgba(255, 255, 255, 0.025);
        }

        .dimension-info {
            flex: 1;
            min-width: 0;
        }

        .dimension-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dimension-meta {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .dimension-actions {
            display: flex;
            gap: 5px;
            align-items: center;
            flex-shrink: 0;
        }

        .btn-icon {
            padding: 5px 9px;
            background: transparent;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text-secondary);
            cursor: pointer;
            transition: all 0.18s;
            font-size: 11px;
            font-family: inherit;
            white-space: nowrap;
        }

        .btn-icon:hover {
            background: rgba(255,255,255,0.06);
            color: var(--color-text-primary);
        }

        .btn-icon.delete:hover {
            background: rgba(142,59,95,0.15);
            border-color: var(--color-accent-red);
            color: #e07070;
        }

        .collapse-icon {
            font-size: 11px;
            transition: transform 0.25s ease;
            color: var(--color-text-secondary);
            flex-shrink: 0;
            pointer-events: none;
            margin-right: 4px;
            opacity: 0.7;
        }

        .collapse-icon.expanded {
            transform: rotate(180deg);
        }

        /* Path Card */
        .dimension-content {
            padding: 0 12px 12px;
            display: none;
        }

        .dimension-content.expanded {
            display: block;
        }

        .path-card {
            background: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            border-radius: 9px;
            margin-bottom: 9px;
        }

        .path-header {
            padding: 12px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            transition: background 0.18s;
        }

        .path-header:hover {
            background: rgba(255, 255, 255, 0.025);
        }

        .path-header > div:first-child {
            flex: 1;
            min-width: 0;
        }

        .path-name {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .path-content {
            padding: 0 10px 10px;
            display: none;
        }

        .path-content.expanded {
            display: block;
        }

        /* Activity Item */
        .activity-item {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 10px;
            padding: 13px 14px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.18s ease;
            position: relative;
            overflow: hidden;
        }

        /* Pending (not yet done) — prominent, tappable */
        .activity-item:not(.completed):not(.disabled):not(.permanently-done) {
            background: var(--color-bg-card);
            border-color: var(--color-border);
        }

        .activity-item:not(.completed):not(.disabled):not(.permanently-done):hover {
            background: var(--color-bg-secondary);
            border-color: var(--color-accent-blue);
            box-shadow: 0 2px 12px rgba(68,114,160,0.18);
        }

        .activity-item:not(.completed):not(.disabled):not(.permanently-done):active {
            transform: scale(0.98);
        }

        /* Left accent bar — only on pending items */
        .activity-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            background: var(--color-accent-blue);
            border-radius: 99px 0 0 99px;
            opacity: 0;
            transition: opacity 0.18s;
        }
        .activity-item:not(.completed):not(.disabled):not(.permanently-done):hover::before {
            opacity: 1;
        }

        /* Completed — visually muted and checked */
        .activity-item.completed {
            background: rgba(68, 114, 160, 0.06);
            border-color: rgba(68, 114, 160, 0.25);
            cursor: pointer;
            opacity: 1;
        }

        .activity-item.completed:hover {
            background: rgba(68, 114, 160, 0.1);
            border-color: rgba(68, 114, 160, 0.4);
        }

        .activity-item.completed .activity-name {
            text-decoration: line-through;
            color: var(--color-text-secondary);
        }

        /* Multi-complete: completed at least once but still clickable for more */
        .activity-item.completed-multi {
            background: rgba(68, 114, 160, 0.04);
            border-color: rgba(68, 114, 160, 0.2);
            cursor: pointer;
        }

        .activity-item.completed-multi:hover {
            background: rgba(68, 114, 160, 0.09);
            border-color: rgba(68, 114, 160, 0.35);
        }

        /* Permanently done one-time activity */
        .activity-item.permanently-done {
            background: rgba(107, 124, 63, 0.06);
            border-color: rgba(107, 124, 63, 0.2);
            cursor: default;
            opacity: 0.7;
        }
        .activity-item.permanently-done .activity-name {
            text-decoration: line-through;
            color: var(--color-text-secondary);
        }

        .activity-item.disabled {
            cursor: not-allowed;
            opacity: 0.4;
        }

        .activity-info-container {
            flex: 1;
            min-width: 0;
        }

        .activity-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            transition: color 0.18s;
        }

        .activity-details {
            font-size: 11px;
            color: var(--color-text-secondary);
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .activity-badge {
            padding: 2px 7px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        .badge-frequency {
            background: rgba(74, 124, 158, 0.15);
            color: var(--color-accent-blue);
        }

        .badge-xp {
            background: rgba(107, 124, 63, 0.15);
            color: var(--color-accent-green);
        }

        .badge-negative {
            background: rgba(142, 59, 95, 0.15);
            color: var(--color-accent-red);
        }

        .badge-streak {
            background: rgba(122, 123, 77, 0.15);
            color: var(--color-accent-olive);
        }

        .badge-counter {
            background: rgba(74, 124, 158, 0.2);
            color: var(--color-accent-blue);
            border: 1px solid rgba(74, 124, 158, 0.4);
        }

        /* Day picker for custom schedule */
        .day-picker {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .day-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.04);
            color: var(--color-text-secondary);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .day-btn:hover {
            border-color: rgba(74,124,158,0.5);
            background: rgba(74,124,158,0.1);
        }
        .day-btn.selected {
            background: var(--color-accent-blue);
            border-color: var(--color-accent-blue);
            color: #fff;
        }
        .custom-subtype-row {
            display: flex;
            gap: 6px;
        }
        .custom-subtype-btn {
            flex: 1;
            padding: 10px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.04);
            color: var(--color-text-secondary);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
            font-family: inherit;
        }
        .custom-subtype-btn:hover {
            border-color: rgba(74,124,158,0.4);
        }
        .custom-subtype-btn.active {
            border-color: var(--color-accent-blue);
            background: var(--color-accent-blue);
            color: #ffffff;
            font-weight: 600;
        }

        /* Check circle indicator for completed */
        .activity-check {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-left: 10px;
            transition: all 0.18s;
            color: transparent;
            font-size: 13px;
            font-weight: 700;
        }

        .activity-item:not(.completed):not(.disabled):not(.permanently-done) .activity-check {
            border-color: var(--color-border);
        }

        .activity-item:not(.completed):not(.disabled):not(.permanently-done):hover .activity-check {
            border-color: var(--color-accent-blue);
            background: rgba(68,114,160,0.1);
            color: var(--color-accent-blue);
        }

        .activity-item.completed .activity-check {
            background: var(--color-accent-blue);
            border-color: var(--color-accent-blue);
            color: #fff;
        }

        .activity-item.permanently-done .activity-check {
            background: var(--color-accent-green);
            border-color: var(--color-accent-green);
            color: #fff;
        }

        /* Legacy .activity-status kept for dimensions tab */
        .activity-status {
            padding: 4px 10px;
            background: rgba(107, 124, 63, 0.15);
            color: var(--color-accent-green);
            border: 1px solid rgba(107, 124, 63, 0.25);
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .activity-item.completed .activity-status {
            background: rgba(107, 124, 63, 0.2);
        }

        .activity-item.completed:hover .activity-status {
            background: rgba(122, 123, 77, 0.3);
            color: var(--color-accent-olive);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.72);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 16px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #262626;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.07);
            max-width: 480px;
            width: 100%;
            max-height: 92vh;
            overflow-y: auto;
            box-shadow: 0 24px 64px rgba(0,0,0,0.65);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 24px 24px 0;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.02em;
            color: var(--color-text-primary);
        }

        .modal-body {
            padding: 20px 24px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid rgba(255,255,255,0.06);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            background: rgba(0,0,0,0.15);
            border-radius: 0 0 16px 16px;
        }

        /* ── Field label ── */
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-group label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: var(--color-text-secondary);
            line-height: 1;
        }

        /* ── All text inputs ── */
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group input[type="url"],
        .form-group input[type="email"],
        .form-group input[type="password"],
        .form-group input[type="date"] {
            width: 100%;
            height: 40px;
            padding: 0 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: var(--color-text-primary);
            font-size: 13px;
            font-weight: 400;
            font-family: inherit;
            box-sizing: border-box;
            -webkit-appearance: none;
            appearance: none;
            transition: border-color 0.15s, background 0.15s;
            color-scheme: dark;
        }

        .form-group input[type="text"]:focus,
        .form-group input[type="number"]:focus,
        .form-group input[type="url"]:focus,
        .form-group input[type="email"]:focus,
        .form-group input[type="password"]:focus,
        .form-group input[type="date"]:focus {
            outline: none;
            border-color: var(--color-accent-blue);
            background: rgba(74,124,158,0.08);
        }

        .form-group input::placeholder {
            color: rgba(176,176,176,0.5);
            font-size: 13px;
        }

        .form-group input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(0.5);
            cursor: pointer;
        }

        /* ── Select ── */
        .form-group select {
            width: 100%;
            height: 40px;
            padding: 0 32px 0 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: var(--color-text-primary);
            font-size: 13px;
            font-weight: 400;
            font-family: inherit;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            box-sizing: border-box;
            transition: border-color 0.15s, background 0.15s;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            /* Force browser to render the native dropdown in dark mode */
            color-scheme: dark;
        }

        .form-group select:focus {
            outline: none;
            border-color: var(--color-accent-blue);
            background-color: rgba(74,124,158,0.08);
        }

        /* Style the native option elements for browsers that support it */
        .form-group select option {
            background: #2a2a2a;
            color: #ffffff;
            font-size: 13px;
            padding: 8px 12px;
        }

        .form-group select option:checked {
            background: #3a3a4a;
            color: #ffffff;
        }

        /* ── Textarea ── */
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: var(--color-text-primary);
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            min-height: 72px;
            box-sizing: border-box;
            line-height: 1.5;
            transition: border-color 0.15s;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: var(--color-accent-blue);
        }

        /* ── Hint text below a field ── */
        .form-hint {
            font-size: 11px;
            color: var(--color-text-secondary);
            opacity: 0.65;
            line-height: 1.5;
            margin-top: 1px;
        }

        /* ── Two-column row (used in Challenge modal, NOT activity) ── */
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        /* ── Section divider inside modal body ── */
        .form-divider {
            height: 1px;
            background: rgba(255,255,255,0.06);
            margin: 2px 0;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 16px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--color-border);
            border-radius: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
        }

        /* Modern toggle switch */
        .toggle-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 11px 14px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--color-border);
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
        }

        .toggle-row:hover {
            background: rgba(255,255,255,0.05);
            border-color: rgba(255,255,255,0.12);
        }

        .toggle-label {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .toggle-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--color-text-primary);
        }

        .toggle-sub {
            font-size: 11px;
            color: var(--color-text-secondary);
            line-height: 1.4;
        }

        .toggle-switch {
            position: relative;
            width: 42px;
            height: 24px;
            flex-shrink: 0;
        }

        .toggle-switch input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .toggle-knob {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.12);
            border-radius: 99px;
            transition: background 0.2s;
            cursor: pointer;
        }

        .toggle-knob::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            left: 3px;
            top: 3px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
            box-shadow: 0 1px 4px rgba(0,0,0,0.4);
        }

        .toggle-switch input:checked + .toggle-knob {
            background: var(--color-accent-blue);
        }

        .toggle-switch input:checked + .toggle-knob::after {
            transform: translateX(18px);
        }

        /* Form section inset — for nested options */
        .form-section-inset {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .activity-checklist-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .activity-checklist-item:hover {
            background: rgba(255,255,255,0.05);
        }

        .activity-checklist-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--color-accent-blue);
            flex-shrink: 0;
        }

        .activity-checklist-item label {
            font-size: 13px;
            color: var(--color-text-primary);
            cursor: pointer;
            line-height: 1.4;
            flex: 1;
        }

        .activity-checklist-item label span {
            display: block;
            font-size: 11px;
            color: var(--color-text-secondary);
        }

        .activity-checklist-item .target-input-wrap {
            display: none;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .activity-checklist-item.checked .target-input-wrap {
            display: flex;
        }

        .activity-checklist-item .target-input-wrap input[type="number"] {
            width: 62px;
            padding: 4px 8px;
            background: var(--color-bg-primary);
            border: 1px solid var(--color-accent-blue);
            border-radius: 6px;
            color: var(--color-text-primary);
            font-size: 13px;
            text-align: center;
        }

        .activity-checklist-item .target-input-wrap label {
            font-size: 11px;
            color: var(--color-text-secondary);
            cursor: default;
            white-space: nowrap;
        }


        .btn-secondary {
            padding: 9px 20px;
            background: rgba(255,255,255,0.06);
            color: var(--color-text-primary);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.1);
        }

        .btn-primary {
            padding: 9px 22px;
            background: var(--color-accent-blue);
            color: var(--color-text-primary);
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--color-text-secondary);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .level-lock-notice {
            background: rgba(142, 59, 95, 0.1);
            border: 1px solid rgba(142, 59, 95, 0.3);
            color: var(--color-accent-red);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            text-align: center;
        }

        /* Themed scrollbars — applied globally to every scrollable element */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--color-accent-blue) var(--color-bg-secondary);
        }

        *::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        *::-webkit-scrollbar-track {
            background: var(--color-bg-secondary);
            border-radius: 3px;
        }

        *::-webkit-scrollbar-thumb {
            background: var(--color-accent-blue);
            border-radius: 3px;
        }

        *::-webkit-scrollbar-thumb:hover {
            background: var(--color-progress);
        }

        *::-webkit-scrollbar-corner {
            background: var(--color-bg-secondary);
        }

        .btn-complete-challenge {
            padding: 6px 12px;
            background: rgba(107, 124, 63, 0.15);
            color: var(--color-accent-green);
            border: 1px solid rgba(107, 124, 63, 0.4);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-complete-challenge:hover {
            background: rgba(107, 124, 63, 0.35);
            border-color: var(--color-accent-green);
            color: #fff;
        }

        .btn-complete-ready {
            background: rgba(107, 124, 63, 0.3);
            border-color: var(--color-accent-green);
            color: #fff;
            animation: pulse-green 2s ease-in-out infinite;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 0 0 rgba(107, 124, 63, 0.5); }
            50% { box-shadow: 0 0 0 6px rgba(107, 124, 63, 0); }
        }

        /* ── Rewards Tab ───────────────────────────────────────────────── */

        .rewards-intro {
            text-align: center;
            padding: 16px 0 28px;
        }

        .rewards-intro p {
            color: var(--color-text-secondary);
            font-size: 15px;
            max-width: 520px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .rewards-timeline {
            position: relative;
            padding-left: 48px;
        }

        .rewards-timeline::before {
            content: '';
            position: absolute;
            left: 19px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, var(--color-accent-blue), var(--color-accent-olive), var(--color-accent-green));
            border-radius: 1px;
            opacity: 0.5;
        }

        .reward-node {
            position: relative;
            margin-bottom: 20px;
        }

        .reward-node-dot {
            position: absolute;
            left: -36px;
            top: 18px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid var(--color-border);
            background: var(--color-bg-primary);
            z-index: 1;
            transition: all 0.3s;
        }

        .reward-node.unlocked .reward-node-dot {
            background: var(--color-accent-green);
            border-color: var(--color-accent-green);
            box-shadow: 0 0 10px rgba(107, 124, 63, 0.6);
        }

        .reward-node.current .reward-node-dot {
            background: var(--color-accent-blue);
            border-color: var(--color-progress);
            width: 18px;
            height: 18px;
            left: -38px;
            top: 16px;
            box-shadow: 0 0 14px rgba(90, 159, 212, 0.7);
            animation: pulse-blue 2s ease-in-out infinite;
        }

        @keyframes pulse-blue {
            0%, 100% { box-shadow: 0 0 0 0 rgba(90, 159, 212, 0.6); }
            50% { box-shadow: 0 0 0 8px rgba(90, 159, 212, 0); }
        }

        .reward-node.future .reward-node-dot {
            background: var(--color-bg-secondary);
            border-color: var(--color-border);
        }

        .reward-card {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 18px 20px;
            cursor: default;
            transition: all 0.25s;
            position: relative;
            overflow: hidden;
        }

        .reward-card::before {
            content: '';
            position: absolute;
            left: 0; top: 0; bottom: 0;
            width: 3px;
            border-radius: 2px 0 0 2px;
            background: var(--color-border);
            transition: background 0.3s;
        }

        .reward-node.unlocked .reward-card {
            border-color: rgba(107, 124, 63, 0.4);
            background: linear-gradient(135deg, rgba(107,124,63,0.08) 0%, var(--color-bg-card) 100%);
        }

        .reward-node.unlocked .reward-card::before { background: var(--color-accent-green); }

        .reward-node.current .reward-card {
            border-color: rgba(74, 124, 158, 0.6);
            background: linear-gradient(135deg, rgba(74,124,158,0.12) 0%, var(--color-bg-card) 100%);
            box-shadow: 0 4px 20px rgba(74, 124, 158, 0.15);
        }

        .reward-node.current .reward-card::before { background: var(--color-accent-blue); }

        .reward-node.future .reward-card {
            opacity: 0.55;
        }

        .reward-node.future .reward-card::before { background: var(--color-border); }

        .reward-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        .reward-level-label {
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .reward-node.unlocked .reward-level-label { color: var(--color-accent-green); }
        .reward-node.current  .reward-level-label { color: var(--color-progress); }
        .reward-node.future   .reward-level-label { color: var(--color-text-secondary); }

        .reward-status-badge {
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .badge-unlocked  { background: rgba(107,124,63,0.25);  color: var(--color-accent-green); }
        .badge-current   { background: rgba(74,124,158,0.25);  color: var(--color-progress); }
        .badge-upcoming  { background: rgba(255,255,255,0.06); color: var(--color-text-secondary); }

        .reward-title {
            font-size: 17px;
            font-weight: 600;
            margin: 8px 0 4px;
            color: var(--color-text-primary);
        }

        .reward-node.future .reward-title {
            color: var(--color-text-secondary);
        }

        .reward-desc {
            font-size: 13px;
            color: var(--color-text-secondary);
            line-height: 1.5;
        }

        .reward-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 14px;
        }

        .btn-reward-edit {
            padding: 5px 12px;
            background: transparent;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-reward-edit:hover {
            border-color: var(--color-accent-blue);
            color: var(--color-text-primary);
            background: rgba(74,124,158,0.1);
        }

        .btn-reward-add {
            padding: 5px 12px;
            background: rgba(74,124,158,0.1);
            border: 1px dashed rgba(74,124,158,0.4);
            border-radius: 6px;
            color: var(--color-accent-blue);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-reward-add:hover {
            background: rgba(74,124,158,0.2);
            border-color: var(--color-accent-blue);
        }

        /* Reward unlock celebration overlay */
        .reward-unlock-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10010;
            padding: 20px;
            animation: fadeInOverlay 0.4s ease;
        }

        @keyframes fadeInOverlay {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .reward-unlock-card {
            background: var(--color-bg-card);
            border: 2px solid var(--color-accent-olive);
            border-radius: 24px;
            padding: 48px 40px;
            max-width: 440px;
            width: 100%;
            text-align: center;
            position: relative;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 60px rgba(122,123,77,0.3);
        }

        @keyframes popIn {
            from { transform: scale(0.6); opacity: 0; }
            to   { transform: scale(1); opacity: 1; }
        }

        .reward-unlock-icon {
            font-size: 64px;
            display: block;
            margin-bottom: 16px;
            animation: spin-once 0.6s ease 0.2s both;
        }

        @keyframes spin-once {
            from { transform: rotate(-20deg) scale(0.8); }
            to   { transform: rotate(0deg) scale(1); }
        }

        .reward-unlock-level {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--color-accent-olive);
            margin-bottom: 8px;
        }

        .reward-unlock-title {
            font-size: 26px;
            font-weight: 700;
            margin-bottom: 12px;
            color: var(--color-text-primary);
        }

        .reward-unlock-desc {
            font-size: 15px;
            color: var(--color-text-secondary);
            line-height: 1.6;
            margin-bottom: 28px;
        }

        .btn-reward-claim {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
            padding: 8px 18px;
            background: linear-gradient(135deg, var(--color-accent-olive), var(--color-accent-green));
            color: #fff;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 16px rgba(107,124,63,0.4);
        }

        .btn-reward-claim:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* Reward modal */
        .modal-wide { max-width: 480px; }

        /* ── Analytics Tab ──────────────────────────────────────────────── */

        .analytics-filters {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-label {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--color-text-secondary);
        }

        .filter-pills {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .filter-pill {
            padding: 5px 12px;
            background: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            border-radius: 20px;
            color: var(--color-text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .filter-pill:hover {
            border-color: var(--color-accent-blue);
            color: var(--color-text-primary);
        }

        .filter-pill.active {
            background: var(--color-accent-blue);
            border-color: var(--color-accent-blue);
            color: #fff;
        }

        .filter-select {
            padding: 6px 10px;
            background: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            color: var(--color-text-primary);
            font-size: 13px;
            cursor: pointer;
            min-width: 160px;
        }

        .filter-select:focus { outline: none; border-color: var(--color-accent-blue); }

        .analytics-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .analytics-stat {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 10px;
            padding: 16px;
            text-align: center;
        }

        .analytics-stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--color-text-primary);
            line-height: 1;
        }

        .analytics-stat-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            margin-top: 6px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .analytics-card {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .analytics-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .analytics-card-title {
            font-size: 16px;
            font-weight: 600;
        }

        .analytics-two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .analytics-two-col .analytics-card {
            margin-bottom: 0;
        }

        /* Chart canvas wrapper */
        .chart-container {
            position: relative;
            height: 220px;
        }

        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .chart-empty {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        /* Horizontal bar rows for leaderboard / frequency */
        .rank-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .rank-num {
            width: 22px;
            font-size: 12px;
            color: var(--color-text-secondary);
            text-align: right;
            flex-shrink: 0;
        }

        .rank-label {
            width: 120px;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }

        .rank-bar-track {
            flex: 1;
            height: 8px;
            background: var(--color-bg-secondary);
            border-radius: 4px;
            overflow: hidden;
        }

        .rank-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .rank-value {
            width: 52px;
            font-size: 12px;
            color: var(--color-text-secondary);
            text-align: right;
            flex-shrink: 0;
        }

        /* Calendar */
        .calendar-month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .calendar-dow {
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--color-text-secondary);
            padding: 4px 0 8px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .calendar-day {
            aspect-ratio: 1;
            border-radius: 6px;
            background: var(--color-bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--color-text-secondary);
            cursor: default;
            position: relative;
            transition: transform 0.15s;
        }

        .calendar-day.has-data {
            cursor: pointer;
        }

        .calendar-day.has-data:hover {
            transform: scale(1.15);
            z-index: 2;
        }

        .calendar-day.today {
            border: 1px solid var(--color-accent-blue);
        }

        .calendar-day.empty {
            background: transparent;
        }

        .calendar-tooltip {
            position: fixed;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 12px;
            z-index: 2000;
            pointer-events: none;
            max-width: 200px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            line-height: 1.6;
        }

        /* Time of day chart */
        .tod-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .tod-label {
            width: 80px;
            font-size: 12px;
            color: var(--color-text-secondary);
            flex-shrink: 0;
        }

        .tod-bar-track {
            flex: 1;
            height: 20px;
            background: var(--color-bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .tod-bar-fill {
            height: 100%;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-size: 11px;
            color: rgba(255,255,255,0.8);
            font-weight: 600;
            transition: width 0.5s ease;
        }

        .tod-count {
            width: 30px;
            font-size: 12px;
            color: var(--color-text-secondary);
            text-align: right;
            flex-shrink: 0;
        }

        /* Combo chips */
        .combo-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .combo-chip {
            padding: 3px 10px;
            background: rgba(74,124,158,0.15);
            border: 1px solid rgba(74,124,158,0.3);
            border-radius: 20px;
            font-size: 12px;
            color: var(--color-progress);
        }

        .combo-count {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .analytics-two-col { grid-template-columns: 1fr; }
            .rank-label { width: 80px; }
        }

        /* ── Settings Cards ──────────────────────────────────────────────── */

        .settings-card {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 14px;
            padding: 22px 24px;
            margin-bottom: 16px;
        }

        .settings-card-header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 20px;
        }

        .settings-icon {
            font-size: 26px;
            width: 44px;
            height: 44px;
            background: var(--color-bg-secondary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .settings-card-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .settings-card-sub {
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .settings-note {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .btn-settings-save {
            padding: 9px 22px;
            background: var(--color-accent-blue);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn-settings-save:hover { opacity: 0.85; }

        /* ── Theme ───────────────────────────────────────────────────────── */

        .theme-presets {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .theme-swatch {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 8px;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .theme-swatch:hover { border-color: var(--color-border); background: var(--color-bg-secondary); }

        .theme-swatch.active { border-color: var(--color-accent-blue); background: rgba(74,124,158,0.1); }

        .theme-swatch-colors {
            display: flex;
            gap: 3px;
        }

        .theme-swatch-dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
        }

        .theme-swatch-name {
            font-size: 11px;
            color: var(--color-text-secondary);
            font-weight: 500;
        }

        .color-picker {
            width: 44px;
            height: 34px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background: none;
            cursor: pointer;
            padding: 2px;
            flex-shrink: 0;
        }

        .theme-custom-row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        /* ── Streak Pause ─────────────────────────────────────────────────── */

        .streak-pause-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid var(--color-border);
        }

        .streak-pause-item:last-child { border-bottom: none; }

        .streak-pause-info { flex: 1; }

        .streak-pause-name { font-size: 14px; font-weight: 500; }

        .streak-pause-meta {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-top: 2px;
        }

        .streak-pause-uses {
            display: flex;
            gap: 4px;
        }

        .streak-use-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--color-border);
        }

        .streak-use-dot.used { background: var(--color-accent-olive); }

        .btn-pause-streak {
            padding: 5px 14px;
            background: rgba(122,123,77,0.15);
            border: 1px solid rgba(122,123,77,0.4);
            border-radius: 6px;
            color: var(--color-accent-olive);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-pause-streak:hover { background: rgba(122,123,77,0.3); }

        .btn-pause-streak:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .streak-paused-badge {
            padding: 3px 10px;
            background: rgba(107,124,63,0.2);
            border-radius: 20px;
            font-size: 11px;
            color: var(--color-accent-green);
            font-weight: 600;
        }

        /* ── Data Actions ─────────────────────────────────────────────────── */

        .data-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .btn-data {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            border-radius: 10px;
            border: 1px solid var(--color-border);
            background: var(--color-bg-secondary);
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .btn-data:hover { transform: translateY(-2px); box-shadow: 0 4px 16px rgba(0,0,0,0.3); }

        .btn-data-export:hover { border-color: var(--color-accent-green); background: rgba(107,124,63,0.08); }
        .btn-data-import:hover { border-color: var(--color-accent-blue);  background: rgba(74,124,158,0.08); }
        .btn-data-reset:hover  { border-color: var(--color-accent-red);   background: rgba(142,59,95,0.08); }

        .btn-data-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; color: inherit; }

        .btn-data-label {
            display: flex;
            flex-direction: column;
            font-size: 13px;
            font-weight: 600;
            color: var(--color-text-primary);
            line-height: 1.3;
        }

        .btn-data-label span {
            font-size: 11px;
            font-weight: 400;
            color: var(--color-text-secondary);
            margin-top: 2px;
        }

        /* Responsive — shared mobile styles */
        @media (max-width: 768px) {
            .level-display { font-size: 42px; }

            .analytics-two-col { grid-template-columns: 1fr; }
            .rank-label { width: 80px; }

            .main-content {
                padding: 16px 12px;
            }

            /* Keep date form-rows as 2-col on tablets, single col on phones handled in 480px */
            .section-header {
                flex-direction: row;
                align-items: center;
                gap: 8px;
            }

            .settings-card {
                padding: 16px;
            }

            .theme-presets {
                gap: 6px;
            }

            .data-actions {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                gap: 8px;
            }

            .stat-card {
                padding: 14px 10px;
            }

            .stat-value {
                font-size: 24px;
            }

            .stat-label {
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            .section-title { font-size: 17px; }
            .btn-add { padding: 7px 12px; font-size: 12px; }
            .stat-value { font-size: 20px; }
            .stat-label { font-size: 10px; }
            .stat-card { padding: 12px 8px; }

            .level-display { font-size: 36px; }
            .header-xp-current { font-size: 14px; }
            .header-xp-label { font-size: 8px; }
            .header-meta-right { font-size: 9px; }
            .header-content { padding: 10px 14px; }
            .progress-bar-container { height: 9px; }
            .btn-logout { font-size: 11px; padding: 5px 8px; }

            /* Modals: full-width, slim padding */
            .modal { border-radius: 14px; }
            .modal-header { padding: 18px 18px 0; }
            .modal-body { padding: 16px 18px; gap: 12px; }
            .modal-footer { padding: 13px 18px; }
            .modal-title { font-size: 17px; }

            /* On very small screens, let Dim+Path stack */
            #activityDimPathGroup .form-row { grid-template-columns: 1fr; }
            .form-row { grid-template-columns: 1fr; }
        }
        /* ── Activity Group Collapsible ──────────────────────────────────── */
        .act-group { margin-bottom: 8px; }

        .act-group-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 4px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            border-bottom: 1px solid var(--color-border);
            margin-bottom: 8px;
        }

        .act-group-header:hover { opacity: 0.85; }

        .act-group-label {
            font-size: 15px;
            font-weight: 700;
            letter-spacing: -0.02em;
            flex: 1;
        }

        .act-group-count {
            font-size: 11px;
            color: var(--color-text-secondary);
            background: var(--color-bg-secondary);
            border-radius: 20px;
            padding: 2px 8px;
            font-weight: 600;
        }

        .act-group-body { display: none; }
        .act-group-body.expanded { display: block; }

        .guide-section-body { display: none; flex-direction: column; gap: 12px; margin-top: 16px; }
        .guide-section-body.open { display: flex; }
        .guide-toggle-btn { display: flex; align-items: center; gap: 10px; cursor: pointer; width: 100%; background: none; border: none; color: var(--color-text-primary); font-family: inherit; text-align: left; }
        .guide-toggle-btn .guide-chevron { font-size: 12px; color: var(--color-text-secondary); transition: transform 0.2s; }
        .guide-toggle-btn.open .guide-chevron { transform: rotate(180deg); }
        .guide-inner-card { background: var(--color-bg-secondary); border-radius: 10px; padding: 14px 16px; }
        .guide-inner-title { font-size: 14px; font-weight: 600; margin-bottom: 6px; }
        .guide-inner-body { font-size: 13px; color: var(--color-text-secondary); line-height: 1.6; }

        /* Additional Polish */
        .nav-tab {
            font-family: 'Inter', sans-serif;
            letter-spacing: -0.01em;
        }

        .section-title {
            font-weight: 700;
            letter-spacing: -0.03em;
        }

        .stat-card {
            border-radius: 14px;
        }

        .stat-value {
            font-weight: 800;
            letter-spacing: -0.03em;
        }

        .dimension-name {
            letter-spacing: -0.02em;
        }

        .analytics-card-title {
            font-weight: 700;
            letter-spacing: -0.02em;
            font-size: 15px;
        }

        .settings-card-title {
            letter-spacing: -0.02em;
        }

        /* Smoother buttons */
        .btn, .btn-primary, .btn-secondary, .btn-add, .btn-settings-save,
        .btn-complete-challenge, .btn-pause-streak, .btn-reward-claim {
            font-family: 'Inter', sans-serif;
            letter-spacing: -0.01em;
        }

        /* Auth card polish */
        .auth-brand-name {
            font-weight: 800;
            letter-spacing: -0.03em;
        }

        /* Streak meta clean */
        .streak-pause-meta {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-top: 3px;
        }

        /* Stat card grid for mobile - 3 columns */
        @media (max-width: 400px) {
            .stats-grid {
                grid-template-columns: 1fr 1fr 1fr;
            }
            .stat-card {
                padding: 10px 8px;
            }
            .stat-value {
                font-size: 20px;
            }
            .stat-label {
                font-size: 10px;
            }
        }

        /* ── Challenge Cards ──────────────────────────────────────────────── */
        .challenge-card {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            transition: box-shadow 0.2s;
        }
        .challenge-card.completed { border-color: var(--color-accent-green); opacity: 0.85; }
        .challenge-card.failed { border-color: var(--color-accent-red); opacity: 0.6; }
        .challenge-card.targets-met { border-color: var(--color-accent-green); box-shadow: 0 0 20px rgba(107,124,63,0.3); }
        .ch-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; margin-bottom: 16px; }
        .ch-title { font-size: 17px; font-weight: 700; margin: 0 0 4px 0; line-height: 1.3; }
        .ch-desc { font-size: 13px; color: var(--color-text-secondary); margin: 0; line-height: 1.5; }
        .ch-actions { display: flex; gap: 6px; flex-shrink: 0; align-items: center; }
        .ch-ready-banner {
            display: flex; align-items: center; gap: 8px;
            background: rgba(107,124,63,0.12); border: 1px solid rgba(107,124,63,0.35);
            border-radius: 10px; padding: 10px 14px; margin-bottom: 14px;
            font-size: 13px; color: var(--color-accent-green);
        }
        .ch-progress-block { margin-bottom: 14px; }
        .ch-progress-label { display: flex; justify-content: space-between; align-items: baseline; font-size: 13px; margin-bottom: 6px; }
        .ch-progress-label-name { font-weight: 600; color: var(--color-text-primary); }
        .ch-progress-label-val { color: var(--color-text-secondary); font-size: 12px; }
        .ch-bar-track { width: 100%; height: 8px; background: var(--color-bg-secondary); border-radius: 4px; overflow: hidden; }
        .ch-bar-fill { height: 100%; border-radius: 4px; transition: width 0.4s ease; }
        .ch-update-row { display: flex; gap: 8px; align-items: center; margin-top: 10px; }
        .ch-update-input {
            flex: 1; padding: 9px 12px; background: var(--color-bg-secondary);
            border: 1px solid var(--color-border); border-radius: 8px;
            color: var(--color-text-primary); font-size: 14px; font-family: inherit; min-width: 0;
        }
        .ch-update-input:focus { outline: none; border-color: var(--color-accent-blue); }
        .ch-update-btn {
            padding: 9px 16px; border-radius: 8px; border: 1px solid var(--color-accent-blue);
            background: rgba(74,124,158,0.15); color: var(--color-accent-blue);
            font-size: 13px; font-weight: 600; cursor: pointer; white-space: nowrap; flex-shrink: 0;
        }
        .ch-update-btn:hover { background: rgba(74,124,158,0.3); }
        .ch-breakdown-toggle {
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; padding: 8px 0 6px; font-size: 12px; color: var(--color-text-secondary);
            user-select: none; border-top: 1px solid var(--color-border); margin-top: 4px;
        }
        .ch-breakdown-toggle:hover { color: var(--color-text-primary); }
        .ch-breakdown-body { overflow: hidden; transition: max-height 0.3s ease, opacity 0.2s ease; opacity: 1; }
        .ch-breakdown-body.collapsed { max-height: 0 !important; opacity: 0; }
        .ch-act-row { display: flex; justify-content: space-between; align-items: baseline; font-size: 12px; margin-bottom: 4px; }
        .ch-act-row-name { color: var(--color-text-secondary); }
        .ch-act-row-name.done { color: var(--color-accent-green); }
        .ch-act-row-count { color: var(--color-text-secondary); font-size: 11px; }
        .ch-act-bar-track { width: 100%; height: 5px; background: var(--color-bg-primary); border-radius: 3px; overflow: hidden; margin-bottom: 8px; }
        .ch-tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 14px; padding-top: 12px; border-top: 1px solid var(--color-border); }
        .metric-toggle-btn {
            width: 100%; padding: 11px 14px; border-radius: 10px;
            border: 1.5px solid var(--color-border); background: var(--color-bg-secondary);
            color: var(--color-text-secondary); font-size: 14px; font-weight: 500;
            cursor: pointer; text-align: left; display: flex; align-items: center; gap: 10px;
            transition: all 0.18s; margin-bottom: 2px;
        }
        .metric-toggle-btn.active { border-color: var(--color-accent-blue); background: rgba(74,124,158,0.1); color: var(--color-text-primary); }
        .metric-toggle-btn .mtb-icon { font-size: 16px; }
        .metric-toggle-btn .mtb-label { flex: 1; }
        .metric-toggle-btn .mtb-check {
            width: 18px; height: 18px; border-radius: 50%;
            border: 2px solid var(--color-border);
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; transition: all 0.18s; flex-shrink: 0;
        }
        .metric-toggle-btn.active .mtb-check { background: var(--color-accent-blue); border-color: var(--color-accent-blue); color: #fff; }
        .ch-metric-panel {
            padding: 14px; background: rgba(74,124,158,0.05);
            border: 1px solid rgba(74,124,158,0.2); border-top: none;
            border-radius: 0 0 10px 10px; margin-bottom: 8px;
        }

        /* Negative XP radio options */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .radio-option {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            cursor: pointer;
            transition: all 0.15s;
        }

        .radio-option:hover {
            border-color: rgba(74,124,158,0.4);
            background: rgba(74,124,158,0.06);
        }

        .radio-option:has(input:checked) {
            border-color: rgba(74,124,158,0.6);
            background: rgba(74,124,158,0.1);
        }

        .radio-option input[type="radio"] {
            flex-shrink: 0;
            margin-top: 3px;
            accent-color: var(--color-accent-blue);
        }

        .radio-option-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .radio-option-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-primary);
        }

        .radio-option-desc {
            font-size: 11px;
            color: var(--color-text-secondary);
            line-height: 1.4;
        }

        /* Explicit undo button on completed activities */
        .btn-undo-activity {
            padding: 4px 9px;
            background: rgba(122,123,77,0.12);
            border: 1px solid rgba(122,123,77,0.35);
            border-radius: 6px;
            color: var(--color-accent-olive);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .btn-undo-activity:hover {
            background: rgba(122,123,77,0.28);
            border-color: var(--color-accent-olive);
        }

        /* Skip-mode activity styling */
        .activity-item.skip-mode-pending {
            border-color: rgba(142,59,95,0.35);
            background: rgba(142,59,95,0.04);
        }

        /* Backup restore button */
        .btn-data-restore:hover { border-color: var(--color-accent-olive); background: rgba(122,123,77,0.08); }

    
        /* Smooth reveal for custom interval subgroup swap */
        #cycleSubGroup, #weekdaySubGroup {
            animation: subtypeFadeIn 0.18s ease;
        }
        @keyframes subtypeFadeIn {
            from { opacity: 0; transform: translateY(-3px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="spinner"></div>
    </div>

    <!-- Authentication Screen -->
    <div id="authContainer" class="auth-container" style="display:none;">
        <div class="auth-panel">
            <!-- Brand -->
            <div class="auth-brand">
                <div class="auth-brand-icon">⚡</div>
                <div class="auth-brand-name">LevelUp</div>
                <div class="auth-brand-tagline">Gamify your life. Track your progress.</div>
            </div>

            <!-- Card -->
            <div class="auth-card">
                <div class="auth-tabs">
                    <button class="auth-tab active" onclick="switchAuthTab('login')">Sign In</button>
                    <button class="auth-tab" onclick="switchAuthTab('signup')">Create Account</button>
                </div>

                <div id="authError" class="error-message"></div>

                <!-- Login Form -->
                <form id="loginForm" class="auth-form active" onsubmit="handleLogin(event)">
                    <div class="auth-field">
                        <label>Email</label>
                        <input type="email" id="loginEmail" placeholder="you@example.com" required autocomplete="email">
                    </div>
                    <div class="auth-field">
                        <label>Password</label>
                        <input type="password" id="loginPassword" placeholder="••••••••" required autocomplete="current-password">
                    </div>
                    <button type="submit" class="btn-auth" id="loginBtn">Sign In</button>
                </form>

                <!-- Signup Form -->
                <form id="signupForm" class="auth-form" onsubmit="handleSignup(event)">
                    <div class="auth-field">
                        <label>Email</label>
                        <input type="email" id="signupEmail" placeholder="you@example.com" required autocomplete="email">
                    </div>
                    <div class="auth-field">
                        <label>Password</label>
                        <input type="password" id="signupPassword" placeholder="Min 6 characters" required minlength="6" autocomplete="new-password">
                    </div>
                    <div class="auth-field">
                        <label>Confirm Password</label>
                        <input type="password" id="signupPasswordConfirm" placeholder="••••••••" required minlength="6" autocomplete="new-password">
                    </div>
                    <button type="submit" class="btn-auth" id="signupBtn">Create Account</button>
                </form>

                <div class="auth-divider">OR</div>

                <button class="btn-google" id="googleBtn" onclick="handleGoogleSignIn()">
                    <div class="btn-google-spinner" id="googleSpinner"></div>
                    <svg width="18" height="18" viewBox="0 0 18 18" id="googleIcon">
                        <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                        <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                        <path fill="#FBBC05" d="M3.964 10.707c-.18-.54-.282-1.117-.282-1.707 0-.593.102-1.17.282-1.709V4.958H.957C.347 6.173 0 7.548 0 9c0 1.452.348 2.827.957 4.042l3.007-2.335z"/>
                        <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z"/>
                    </svg>
                    <span id="googleBtnText">Continue with Google</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="appContainer" class="app-container">
        <!-- Sticky Header -->
        <div class="sticky-header">
            <div class="header-content">
                <div class="header-top">
                    <!-- Left: LEVEL label + big number -->
                    <div class="level-badge">
                        <span class="level-label">Level</span>
                        <div class="level-display"><span id="currentLevel">1</span></div>
                    </div>
                    <!-- Center: XP above bar on left, pct+XP-to-next on right; progress bar below -->
                    <div class="progress-section">
                        <div class="progress-meta">
                            <div>
                                <span class="header-xp-current"><span id="currentXP">0</span></span>
                                <span class="header-xp-label">XP</span>
                            </div>
                            <div class="header-meta-right">
                                <span class="header-meta-pct"><span id="progressPercent">0%</span></span>
                                <span class="header-meta-sep">·</span>
                                <span class="header-meta-xp-left"><span id="xpToNextDisplay">50</span> XP to next</span>
                            </div>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progressBar" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="user-info">
                        <button class="btn-logout" onclick="handleLogout()">Sign out</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Navigation Tabs -->
            <div class="nav-tabs">
                <button class="nav-tab active" data-icon="📋" onclick="switchTab('activities')">Activities</button>
                <button class="nav-tab" data-icon="🪐" onclick="switchTab('dimensions')">Dimensions</button>
                <button class="nav-tab" data-icon="🏆" onclick="switchTab('challenges')">Challenges</button>
                <button class="nav-tab" data-icon="🎁" onclick="switchTab('rewards')">Rewards</button>
                <button class="nav-tab" data-icon="📊" onclick="switchTab('analytics')">Analytics</button>
                <button class="nav-tab" data-icon="⚙️" onclick="switchTab('settings')">Settings</button>
            </div>

            <div class="stats-grid">
                <div class="stat-card blue">
                    <div class="stat-value" id="xpToday">0</div>
                    <div class="stat-label">XP Today</div>
                </div>
                <div class="stat-card red">
                    <div class="stat-value" id="completedToday">0</div>
                    <div class="stat-label">Done Today</div>
                </div>
                <div class="stat-card green">
                    <div class="stat-value" id="longestStreak">0</div>
                    <div class="stat-label">Best Streak</div>
                </div>
            </div>

            <!-- Activities Tab -->
            <div id="activitiesTab" class="tab-content active">
                <div class="section-header">
                <h2 class="section-title">Your Activities</h2>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <span id="activitySlotCount" style="font-size:12px;color:var(--color-text-secondary);"></span>
                        <div style="position:relative;">
                            <button class="btn-filter" id="filterBtn" onclick="toggleFilterPanel()" title="Sort &amp; Filter">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
                                <span id="filterActiveDot" style="display:none;width:6px;height:6px;border-radius:50%;background:#6dbf7e;position:absolute;top:4px;right:4px;"></span>
                            </button>
                            <div class="filter-panel" id="filterPanel" style="display:none;">
                                <div class="filter-panel-title">Sort activities</div>
                                <div class="filter-options" id="filterOptions"></div>
                                <div class="filter-panel-footer">
                                    <button class="btn-filter-default" id="setDefaultFilterBtn" onclick="setDefaultActivitySort()">Set as default view</button>
                                </div>
                            </div>
                        </div>
                        <button class="btn-add" onclick="openQuickAddActivity()">+ Add</button>
                    </div>
                </div>
                <div id="activitiesListContainer"></div>
            </div>

            <!-- Dimensions Tab -->
            <div id="dimensionsTab" class="tab-content">
                <div class="section-header">
                    <h2 class="section-title">Your Dimensions</h2>
                    <button class="btn-add" onclick="openDimensionModal()">
                        + Add Dimension
                    </button>
                </div>
                <div id="dimensionsContainer"></div>
            </div>

            <!-- Challenges Tab -->
            <div id="challengesTab" class="tab-content">
                <div class="section-header">
                    <h2 class="section-title">Challenges</h2>
                    <button class="btn-add" onclick="openChallengeModal()">
                        + Create Challenge
                    </button>
                </div>
                <div id="challengesContainer"></div>
            </div>

            <!-- Rewards Tab -->
            <div id="rewardsTab" class="tab-content">
                <div class="section-header">
                    <h2 class="section-title">Rewards</h2>
                </div>
                <div class="rewards-intro">
                    <p>Define a reward for each level milestone. When you level up, your reward appears front and center to celebrate your progress. 🌟</p>
                </div>
                <div id="rewardsTimeline" class="rewards-timeline"></div>
            </div>

            <!-- Analytics Tab -->
            <div id="analyticsTab" class="tab-content">
                <div class="section-header">
                    <h2 class="section-title">Analytics</h2>
                </div>

                <!-- Filter Bar -->
                <div class="analytics-filters" id="analyticsFilters">
                    <div class="filter-group">
                        <label class="filter-label">View</label>
                        <div class="filter-pills" id="filterViewPills">
                            <button class="filter-pill active" onclick="setAnalyticsFilter('view','all',this)">All</button>
                            <button class="filter-pill" onclick="setAnalyticsFilter('view','dimension',this)">By Dimension</button>
                            <button class="filter-pill" onclick="setAnalyticsFilter('view','path',this)">By Path</button>
                            <button class="filter-pill" onclick="setAnalyticsFilter('view','activity',this)">By Activity</button>
                        </div>
                    </div>
                    <div class="filter-group" id="filterDimGroup" style="display:none;">
                        <label class="filter-label">Dimension</label>
                        <select class="filter-select" id="filterDimSelect" onchange="applyAnalyticsFilters()"></select>
                    </div>
                    <div class="filter-group" id="filterPathGroup" style="display:none;">
                        <label class="filter-label">Path</label>
                        <select class="filter-select" id="filterPathSelect" onchange="applyAnalyticsFilters()"></select>
                    </div>
                    <div class="filter-group" id="filterActivityGroup" style="display:none;">
                        <label class="filter-label">Activity</label>
                        <select class="filter-select" id="filterActivitySelect" onchange="applyAnalyticsFilters()"></select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Period</label>
                        <div class="filter-pills">
                            <button class="filter-pill" onclick="setAnalyticsFilter('period','7d',this)">7 Days</button>
                            <button class="filter-pill" onclick="setAnalyticsFilter('period','30d',this)">30 Days</button>
                            <button class="filter-pill active" onclick="setAnalyticsFilter('period','all',this)">All Time</button>
                        </div>
                    </div>
                </div>

                <!-- Summary Cards -->
                <div class="analytics-summary" id="analyticsSummary"></div>

                <!-- XP Over Time Chart -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <h3 class="analytics-card-title">XP Over Time</h3>
                        <div class="filter-pills" style="gap:6px;">
                            <button class="filter-pill active" onclick="setChartMode('cumulative',this)">Cumulative</button>
                            <button class="filter-pill" onclick="setChartMode('daily',this)">Daily</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="xpChart"></canvas>
                        <div id="xpChartEmpty" class="chart-empty" style="display:none;">No completion data yet</div>
                    </div>
                </div>

                <!-- Activity Leaderboard + Streaks -->
                <div class="analytics-two-col">
                    <div class="analytics-card">
                        <div class="analytics-card-header">
                            <h3 class="analytics-card-title">XP Leaderboard</h3>
                        </div>
                        <div id="xpLeaderboard"></div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-card-header">
                            <h3 class="analytics-card-title">Streak Board</h3>
                        </div>
                        <div id="streakBoard"></div>
                    </div>
                </div>

                <!-- Frequency + Combos -->
                <div class="analytics-two-col">
                    <div class="analytics-card">
                        <div class="analytics-card-header">
                            <h3 class="analytics-card-title">Activity Frequency</h3>
                        </div>
                        <div id="frequencyChart"></div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-card-header">
                            <h3 class="analytics-card-title">Activity Pairs (Same Day)</h3>
                        </div>
                        <div id="combosPanel"></div>
                    </div>
                </div>

                <!-- Activity Heatmap Calendar -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <h3 class="analytics-card-title">Activity Calendar</h3>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <button class="filter-pill" onclick="calendarNav(-1)">‹</button>
                            <span id="calendarMonthLabel" style="font-size:14px;color:var(--color-text-secondary);min-width:120px;text-align:center;"></span>
                            <button class="filter-pill" onclick="calendarNav(1)">›</button>
                        </div>
                    </div>
                    <div style="margin-bottom:14px;">
                        <select id="calendarActivityFilter" class="filter-select" style="width:100%;" onchange="renderCalendar()">
                            <option value="">All Activities</option>
                        </select>
                    </div>
                    <div id="calendarGrid"></div>
                    <div id="calendarTooltip" class="calendar-tooltip" style="display:none;"></div>
                </div>

            </div>

            <!-- Settings Tab -->
            <div id="settingsTab" class="tab-content">
                <div class="section-header">
                    <h2 class="section-title">Settings</h2>
                </div>

                <!-- How to Use Guide (collapsible) -->
                <div class="settings-card" style="margin-bottom:16px;">
                    <button class="guide-toggle-btn" id="guideToggleBtn" onclick="toggleGuide()">
                        <span class="settings-icon" style="font-size:20px;">💡</span>
                        <div style="flex:1;">
                            <div class="settings-card-title">How to Use LevelUp</div>
                            <div class="settings-card-sub">Tap to expand the quick-start guide</div>
                        </div>
                        <span class="guide-chevron">▼</span>
                    </button>
                    <div class="guide-section-body" id="guideBody">
                        <div class="guide-inner-card">
                            <div class="guide-inner-title">🗺️ Step 1 — Build your Structure</div>
                            <div class="guide-inner-body">Go to <strong>Dimensions</strong> and create a life area (e.g. Health). Add a <strong>Path</strong> inside it (e.g. Fitness). Then add <strong>Activities</strong> to each path (e.g. Morning Run). This hierarchy keeps everything organised.</div>
                        </div>
                        <div class="guide-inner-card">
                            <div class="guide-inner-title">📋 Step 2 — Complete Activities &amp; Earn XP</div>
                            <div class="guide-inner-body">The <strong>Activities</strong> tab shows what's due. Tap to mark done and earn XP. Tap again to undo (same day only). <strong>Slots:</strong> L1 = 4 slots, L2 = 5, L3 = 7, L4 = 11 — growing fast as you level up.</div>
                        </div>
                        <div class="guide-inner-card">
                            <div class="guide-inner-title">📅 Frequency Types</div>
                            <div class="guide-inner-body"><strong>Daily</strong> — resets every day, builds streaks. <strong>Occasional</strong> — available every day but no streak pressure. <strong>Weekly / Bi-weekly / Monthly</strong> — periodic, builds streaks. <strong>Custom</strong> — you choose the interval in days.</div>
                        </div>
                        <div class="guide-inner-card">
                            <div class="guide-inner-title">🔥 Streaks &amp; Bonus XP</div>
                            <div class="guide-inner-body">Completing recurring activities consistently grows your streak. From streak 5 onward, you earn an exponential bonus: streak 10 = 4×, streak 20 = 9×, streak 30 = 17× base XP. Occasional activities don't track streaks.</div>
                        </div>
                        <div class="guide-inner-card">
                            <div class="guide-inner-title">⬆️ Leveling</div>
                            <div class="guide-inner-body">Level 1→2 costs only <strong>50 XP</strong>. After that: Base XP × level². Negative activities drain XP within your current level but can't de-level you. Undoing an activity restores the XP and level correctly.</div>
                        </div>
                        <div class="guide-inner-card">
                            <div class="guide-inner-title">🏆 Challenges &amp; 🎁 Rewards</div>
                            <div class="guide-inner-body"><strong>Challenges</strong> are time-boxed goals for bonus XP — link specific activities and set how many times each must be done. <strong>Rewards</strong> attach real-world treats to level milestones. A Level 100 surprise awaits!</div>
                        </div>
                    </div>
                </div>
                <div class="settings-card">
                    <div class="settings-card-header">
                        <span class="settings-icon">⚡</span>
                        <div>
                            <h3 class="settings-card-title">XP Formula</h3>
                            <p class="settings-card-sub">Control how fast you level up</p>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Base XP (quadratic coefficient)</label>
                            <input type="number" id="settingsBaseXP" value="25" min="10" max="1000">
                        </div>
                        <input type="hidden" id="settingsMultiplier" value="1.5">
                    </div>
                    <div style="height:10px;background:rgba(45,45,45,1);"></div>
                    <p class="settings-note">XP to reach level N = Base XP × N² &nbsp;(Level 1→2 is always 50 XP regardless of this setting). Example at 100: L2 = 400, L5 = 2 500, L10 = 10 000 XP.</p>
                    <button class="btn-settings-save" onclick="saveSettings()">Save XP Settings</button>
                </div>

                <!-- Theme Customizer -->
                <div class="settings-card">
                    <div class="settings-card-header">
                        <span class="settings-icon">🎨</span>
                        <div>
                            <h3 class="settings-card-title">Theme</h3>
                            <p class="settings-card-sub">Pick a vibe that suits you</p>
                        </div>
                    </div>
                    <div class="theme-presets" id="themePresets"></div>
                    <input type="color" id="themeAccentPicker" value="#4472a0" style="display:none;" oninput="previewThemeColor('accent',this.value)">
                    <input type="color" id="themeProgressPicker" value="#537db8" style="display:none;" oninput="previewThemeColor('progress',this.value)">
                    <button class="btn-settings-save" onclick="saveTheme()" style="margin-top:16px;">Apply Theme</button>
                </div>

                <!-- Streak Pausing -->
                <div class="settings-card">
                    <div class="settings-card-header">
                        <span class="settings-icon">🛡</span>
                        <div>
                            <h3 class="settings-card-title">Streak Shield</h3>
                            <p class="settings-card-sub">Protect a streak for 1 missed day (max 3 shields per activity). Shields fully reset when a streak breaks, so every new streak starts protected again.</p>
                        </div>
                    </div>
                    <div class="form-group" style="margin-bottom:16px;">
                        <label style="font-size:13px;color:var(--color-text-secondary);margin-bottom:6px;display:block;">Select Activity</label>
                        <select id="streakPauseActivitySelect" class="filter-select" style="width:100%;padding:10px 12px;font-size:14px;" onchange="renderStreakPauseForSelected()">
                            <option value="">— Choose an activity —</option>
                        </select>
                    </div>
                    <div id="streakPauseList"></div>
                </div>

                <!-- Data Management -->
                <div class="settings-card">
                    <div class="settings-card-header">
                        <span class="settings-icon">💾</span>
                        <div>
                            <h3 class="settings-card-title">Data</h3>
                            <p class="settings-card-sub">Import, export, or reset your data</p>
                        </div>
                    </div>
                    <div class="data-actions">
                        <button class="btn-data btn-data-export" onclick="exportData()">
                            <span class="btn-data-icon">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                            </span>
                            <span class="btn-data-label">Export Data<span>Download a JSON backup</span></span>
                        </button>
                        <button class="btn-data btn-data-import" onclick="document.getElementById('importFileInput').click()">
                            <span class="btn-data-icon">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                            </span>
                            <span class="btn-data-label">Import Data<span>Restore from JSON backup</span></span>
                        </button>
                        <input type="file" id="importFileInput" accept=".json" style="display:none;" onchange="importData(event)">
                        <button class="btn-data btn-data-restore" onclick="restoreAutoBackup()" id="restoreBackupBtn">
                            <span class="btn-data-icon">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                            </span>
                            <span class="btn-data-label">Restore Backup<span id="restoreBackupMeta">No backup yet</span></span>
                        </button>
                        <button class="btn-data btn-data-reset" onclick="confirmResetData()">
                            <span class="btn-data-icon">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg>
                            </span>
                            <span class="btn-data-label">Reset All Data<span>Permanently clears everything</span></span>
                        </button>
                    </div>
                    <p class="settings-note" style="margin-top:10px;font-size:11px;line-height:1.6;color:var(--color-text-secondary);">
                        💡 <strong style="color:var(--color-text-primary);">Daily Cloud Backup</strong> — Your data is snapshotted once per day to your account's cloud storage (not just this browser). Works across devices. Only the latest daily snapshot is kept.
                    </p>
                </div>

                <!-- Account -->
                <div class="settings-card">
                    <div class="settings-card-header">
                        <span class="settings-icon">👤</span>
                        <div>
                            <h3 class="settings-card-title">Account</h3>
                            <p class="settings-card-sub">Signed in as <span id="settingsEmail" style="color:var(--color-text-primary);"></span></p>
                        </div>
                    </div>
                    <button class="btn-logout" onclick="handleLogout()">Logout</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confetti Container -->
    <div id="confettiContainer" class="confetti-container"></div>

    <!-- Modals -->
    <!-- Dimension Modal -->
    <div id="dimensionModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="dimensionModalTitle">Create Dimension</h3>
            </div>
            <form id="dimensionForm" onsubmit="saveDimension(event)">
                <div class="modal-body">
                    <div class="form-group">
                        <label>Dimension Name *</label>
                        <input type="text" id="dimensionName" placeholder="e.g., Health, Mind, Knowledge" required>
                    </div>
                    <div class="form-group">
                        <label>Color Theme</label>
                        <select id="dimensionColor">
                            <option value="blue">Blue</option>
                            <option value="red">Red</option>
                            <option value="green">Green</option>
                            <option value="olive">Olive</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" onclick="closeDimensionModal()">Cancel</button>
                    <button type="submit" class="btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Path Modal -->
    <div id="pathModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="pathModalTitle">Create Path</h3>
            </div>
            <form id="pathForm" onsubmit="savePath(event)">
                <div class="modal-body">
                    <div class="form-group">
                        <label>Path Name *</label>
                        <input type="text" id="pathName" placeholder="e.g., Exercise, Reading, Meditation" required>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" onclick="closePathModal()">Cancel</button>
                    <button type="submit" class="btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Challenge Modal -->
    <div id="challengeModal" class="modal-overlay">
        <div class="modal modal-wide">
            <div class="modal-header">
                <h3 class="modal-title" id="challengeModalTitle">Create Challenge</h3>
            </div>
            <form id="challengeForm" onsubmit="saveChallenge(event)">
                <div class="modal-body">
                    <div class="form-group">
                        <label>Challenge Name *</label>
                        <input type="text" id="challengeName" placeholder="e.g., 30-Day Fitness Challenge" required>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="challengeDescription" placeholder="Describe your challenge goal"></textarea>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Start Date *</label>
                            <input type="date" id="challengeStartDate" required>
                        </div>
                        <div class="form-group">
                            <label>End Date *</label>
                            <input type="date" id="challengeEndDate" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Activity Type</label>
                        <select id="challengeActivityType" onchange="onChallengeTypeChange()">
                            <option value="any">Any Activity</option>
                            <option value="specific">Specific Activities</option>
                        </select>
                    </div>
                    <!-- Specific activities selection -->
                    <div class="form-group" id="challengeActivitySelectGroup" style="display: none;">
                        <label>Select Activities &amp; Set Targets</label>
                        <p style="font-size:11px;color:var(--color-text-secondary);margin-top:-2px;">Set how many times each activity must be completed</p>
                        <div id="challengeActivityChecklist" style="
                            background: rgba(255,255,255,0.04);
                            border: 1px solid rgba(255,255,255,0.09);
                            border-radius: 8px;
                            padding: 6px;
                            max-height: 220px;
                            overflow-y: auto;
                            display: flex;
                            flex-direction: column;
                            gap: 2px;
                            margin-top: 4px;
                        "></div>
                        <p id="challengeActivityChecklistEmpty" style="color: var(--color-text-secondary); font-size: 12px; margin-top: 6px; display: none;">No activities found. Create activities first.</p>
                        <div class="form-group" style="margin-top: 6px; margin-bottom: 0;">
                            <label>Bonus XP *</label>
                            <input type="number" id="challengeXPSpecific" placeholder="500" min="1">
                        </div>
                    </div>
                    <!-- Any-activity mode -->
                    <div class="form-row" id="challengeGlobalTargetRow">
                        <div class="form-group">
                            <label>Bonus XP *</label>
                            <input type="number" id="challengeXP" placeholder="500" min="1" required>
                        </div>
                    </div>

                    <!-- ── Goal Metric (optional) ───────────────────────── -->
                    <button type="button" class="metric-toggle-btn" id="metricToggleBtn" onclick="toggleMetricSection()">
                        <span class="mtb-icon">🎯</span>
                        <span class="mtb-label">Track a real-world goal <span style="color:var(--color-text-secondary);font-size:12px;font-weight:400;">(optional)</span></span>
                        <span class="mtb-check" id="metricToggleCheck"></span>
                    </button>
                    <input type="hidden" id="challengeMetricEnabled" value="0">
                    <div id="challengeMetricGroup" style="display:none;" class="ch-metric-panel">
                        <div class="form-row">
                            <div class="form-group">
                                <label>Target Quantity</label>
                                <input type="number" id="challengeMetricQty" placeholder="e.g. 10" min="0.01" step="any">
                            </div>
                            <div class="form-group">
                                <label>Unit</label>
                                <input type="text" id="challengeMetricUnit" placeholder="e.g. kg, pages, km">
                            </div>
                        </div>
                        <p class="form-hint" style="margin-top:0;">💡 Examples: 10 kg (weight loss) · 250 pages (book) · 50 km (running)</p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" onclick="closeChallengeModal()">Cancel</button>
                    <button type="submit" class="btn-primary" id="challengeSubmitBtn">Create Challenge</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Activity Modal -->
    <div id="activityModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="activityModalTitle">Create Activity</h3>
            </div>
            <form id="activityForm" onsubmit="saveActivity(event)">
                <div class="modal-body">

                    <!-- Slot limit notice -->
                    <div id="activityLimitNotice" class="level-lock-notice" style="display:none;">
                        🔒 Activity slots full — <span id="limitCurrent">0</span>/<span id="limitMax">3</span> used.<br>
                        <span style="font-size:12px;">Level up to unlock more (next at Level <span id="limitNextLevel">3</span>).</span>
                    </div>

                    <!-- Dimension + Path (quick-add mode only) -->
                    <div id="activityDimPathGroup" style="display:none;">
                        <div class="form-row">
                            <div class="form-group">
                                <label>Dimension *</label>
                                <select id="activityDimSelect" onchange="populateActivityPathSelect()">
                                    <option value="">— select —</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Path *</label>
                                <select id="activityPathSelect">
                                    <option value="">— select —</option>
                                </select>
                            </div>
                        </div>
                        <p id="activityNoDimsNotice" style="display:none;color:var(--color-accent-red);font-size:12px;padding:9px 12px;background:rgba(142,59,95,0.1);border:1px solid rgba(142,59,95,0.3);border-radius:8px;">
                            No dimensions yet. <button type="button" class="btn-reward-add" onclick="closeActivityModal();switchTab('dimensions');">Create one →</button>
                        </p>
                    </div>

                    <!-- Activity Name -->
                    <div class="form-group">
                        <label>Activity Name *</label>
                        <input type="text" id="activityName" placeholder="e.g., Morning Run, Read 10 pages" required>
                    </div>

                    <!-- Base XP -->
                    <div class="form-group">
                        <label>Base XP *</label>
                        <input type="number" id="activityXP" placeholder="20" min="1" required>
                        <p class="form-hint">Easy habit: 10–30 XP &nbsp;·&nbsp; Difficult habit: 40–80 XP &nbsp;·&nbsp; XP compounds with streaks</p>
                    </div>

                    <!-- Frequency -->
                    <div class="form-group">
                        <label>Frequency *</label>
                        <select id="activityFrequency" onchange="toggleCustomDays()">
                            <option value="daily">Daily</option>
                            <option value="occasional">Occasional (one-off tasks)</option>
                            <option value="weekly">Weekly</option>
                            <option value="biweekly">Bi-weekly</option>
                            <option value="monthly">Monthly</option>
                            <option value="custom">Custom interval</option>
                        </select>
                    </div>

                    <!-- Custom interval panel (only shown when frequency = custom) -->
                    <div id="customDaysGroup" style="display:none;" class="form-section-inset">
                        <!-- Schedule type toggle -->
                        <div class="form-group">
                            <label>Schedule type</label>
                            <div class="custom-subtype-row">
                                <button type="button" class="custom-subtype-btn active" id="subtypeCycle" onclick="setCustomSubtype('cycle')"><span style="font-size:14px;line-height:1">🔁</span> Every X days</button>
                                <button type="button" class="custom-subtype-btn" id="subtypeDays" onclick="setCustomSubtype('days')"><span style="font-size:14px;line-height:1">📅</span> Specific weekdays</button>
                            </div>
                        </div>
                        <!-- Divider between toggle and numeric fields -->
                        <div style="height:10px;background:rgba(45,45,45,1);"></div>
                        <!-- Times per cycle — always shown inside custom -->
                        <div class="form-group">
                            <label>Times to complete per cycle</label>
                            <input type="number" id="activityCustomTimes" placeholder="1" min="1" max="99" value="1">
                        </div>
                        <!-- Divider between toggle and numeric fields -->
                        <div style="height:10px;background:rgba(45,45,45,1);"></div>
                        <!-- Every-X-days: N days input -->
                        <div class="form-group" id="cycleSubGroup">
                            <label>Repeat every how many days?</label>
                            <div style="height:10px;background:rgba(45,45,45,1);"></div>
                            <input type="number" id="activityCustomDays" placeholder="3" min="1" max="365" value="3">
                        </div>
                        <!-- Divider between toggle and numeric fields -->
                        <div style="height:10px;background:rgba(45,45,45,1);"></div>
                        <!-- Specific weekdays: day picker -->
                        <div class="form-group" id="weekdaySubGroup" style="display:none;">
                            <label>Active days of the week</label>
                        <div style="height:10px;background:rgba(45,45,45,1);"></div>
                            <div class="day-picker" id="dayPickerBtns">
                                <button type="button" class="day-btn" data-day="0">Su</button>
                                <button type="button" class="day-btn" data-day="1">Mo</button>
                                <button type="button" class="day-btn" data-day="2">Tu</button>
                                <button type="button" class="day-btn" data-day="3">We</button>
                                <button type="button" class="day-btn" data-day="4">Th</button>
                                <button type="button" class="day-btn" data-day="5">Fr</button>
                                <button type="button" class="day-btn" data-day="6">Sa</button>
                            </div>
                            <p class="form-hint">Activity is only available on highlighted days</p>
                        </div>
                    </div>

                    <!-- Occasional: delete on completion -->
                    <div id="occasionalDeleteGroup" style="display:none;">
                        <label class="toggle-row">
                            <span class="toggle-label">
                                <span class="toggle-title">Delete after completion</span>
                                <span class="toggle-sub">One-time task — disappears once done</span>
                            </span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="activityDeleteOnComplete">
                                <span class="toggle-knob"></span>
                            </div>
                        </label>
                    </div>

                    <!-- Allow multiple completions per day -->
                    <div id="allowMultipleGroup" style="display:none;">
                        <label class="toggle-row">
                            <span class="toggle-label">
                                <span class="toggle-title">Allow multiple times a day</span>
                                <span class="toggle-sub">Each completion earns XP — streak only advances once per cycle</span>
                            </span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="activityAllowMultiple">
                                <span class="toggle-knob"></span>
                            </div>
                        </label>
                    </div>

                    <!-- Enable Negative XP -->
                    <label class="toggle-row">
                        <span class="toggle-label">
                            <span class="toggle-title">Enable Negative XP</span>
                            <span class="toggle-sub">For bad habits or accountability tracking</span>
                        </span>
                        <div class="toggle-switch">
                            <input type="checkbox" id="activityNegativeEnabled" onchange="toggleNegativeXpSection()">
                            <span class="toggle-knob"></span>
                        </div>
                    </label>

                    <!-- Negative XP mode (expanded) -->
                    <div id="negativeXpSection" style="display:none;" class="form-section-inset">
                        <p style="font-size:11px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;color:var(--color-text-secondary);margin-bottom:2px;">When does XP get deducted?</p>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="negativeXpMode" id="negModePerform" value="perform" checked>
                                <div class="radio-option-content">
                                    <span class="radio-option-title">When performed</span>
                                    <span class="radio-option-desc">Logging it costs XP — discourages the habit</span>
                                </div>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="negativeXpMode" id="negModeSkip" value="skip">
                                <div class="radio-option-content">
                                    <span class="radio-option-title">When skipped</span>
                                    <span class="radio-option-desc">Doing it earns XP; missing a day deducts XP</span>
                                </div>
                            </label>
                        </div>
                    </div>

                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" onclick="closeActivityModal()">Cancel</button>
                    <button type="submit" class="btn-primary">Save Activity</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Reward Edit Modal -->
    <div id="rewardModal" class="modal-overlay">
        <div class="modal modal-wide">
            <div class="modal-header">
                <h3 class="modal-title" id="rewardModalTitle">Set Reward for Level <span id="rewardModalLevel"></span></h3>
            </div>
            <form id="rewardForm" onsubmit="saveReward(event)">
                <div class="modal-body">
                    <div class="form-group">
                        <label>Reward Title *</label>
                        <input type="text" id="rewardTitle" placeholder="e.g., Weekend Getaway, New Sneakers…" required>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="rewardDescription" placeholder="Describe what this reward means to you…" style="min-height:90px;"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Link <span style="color:var(--color-text-secondary);font-weight:400;font-size:12px;">(optional — opens in new tab)</span></label>
                        <input type="url" id="rewardLink" placeholder="https://…">
                    </div>
                    <div class="form-group">
                        <label>Icon / Emoji <span style="color:var(--color-text-secondary);font-weight:400;font-size:12px;">(optional)</span></label>
                        <input type="text" id="rewardIcon" placeholder="" maxlength="4" style="font-size:22px; width:80px; text-align:center;">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" onclick="closeRewardModal()">Cancel</button>
                    <button type="submit" class="btn-primary">Save Reward</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Reward Unlock Celebration Overlay -->
    <div id="rewardUnlockOverlay" style="display:none;" class="reward-unlock-overlay" onclick="dismissRewardOverlay()">
        <div class="reward-unlock-card" onclick="event.stopPropagation()">
            <span class="reward-unlock-icon" id="rewardUnlockIcon">🎁</span>
            <div class="reward-unlock-level" id="rewardUnlockLevel">LEVEL UP!</div>
            <div class="reward-unlock-title" id="rewardUnlockTitle">You earned a reward!</div>
            <div class="reward-unlock-desc" id="rewardUnlockDesc"></div>
            <button class="btn-reward-claim" onclick="dismissRewardOverlay()">🎉 Claim Reward</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
        import { getFirestore, doc, getDoc, setDoc } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCLVITDz6EkpSNS1XMuIvRaKEmDNN_h_Eg",
            authDomain: "life-gamification-app-b7674.firebaseapp.com",
            projectId: "life-gamification-app-b7674",
            storageBucket: "life-gamification-app-b7674.firebasestorage.app",
            messagingSenderId: "204483721645",
            appId: "1:204483721645:web:43192b9596feffbd888924"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Global state
        window.currentUser = null;
        window.userData = null;
        window.currentTab = 'activities';

        // Auth State Listener with timeout fallback
        let authCheckTimeout = setTimeout(() => {
            console.error('Auth initialization timeout - showing login screen');
            document.getElementById('loading').style.display = 'none';
            document.getElementById('authContainer').style.display = 'flex';
        }, 5000); // 5 second timeout

        onAuthStateChanged(auth, async (user) => {
            clearTimeout(authCheckTimeout);
            
            const loading = document.getElementById('loading');
            const authContainer = document.getElementById('authContainer');
            const appContainer = document.getElementById('appContainer');

            try {
                if (user) {
                    // Show a lightweight "Loading your data…" in the spinner while Firestore loads
                    window.currentUser = user;
                    await loadUserData(user.uid);
                    
                    loading.style.display = 'none';
                    authContainer.style.display = 'none';
                    appContainer.classList.add('active');
                    
                    const userEmailEl = document.getElementById('userEmail');
                    if (userEmailEl) userEmailEl.textContent = user.email;
                    const settingsEmailEl = document.getElementById('settingsEmail');
                    if (settingsEmailEl) settingsEmailEl.textContent = user.email;
                    loadSettings();
                    processStreakPauses();
                    updateDashboard();
                    // Init the restore backup button visibility (async — non-blocking)
                    updateRestoreBackupBtn().catch(e => {});
                } else {
                    window.currentUser = null;
                    window.userData = null;
                    loading.style.display = 'none';
                    authContainer.style.display = 'flex';
                    appContainer.classList.remove('active');
                }
            } catch (error) {
                console.error('Auth state error:', error);
                loading.style.display = 'none';
                authContainer.style.display = 'flex';
                appContainer.classList.remove('active');
                showError('Failed to load. Please refresh and try again.');
            }
        });

        // Load User Data
        async function loadUserData(uid) {
            try {
                const userDocRef = doc(db, 'users', uid);
                const userDoc = await getDoc(userDocRef);

                if (userDoc.exists()) {
                    window.userData = userDoc.data();
                } else {
                    // Initialize new user data
                    window.userData = {
                        level: 1,
                        currentXP: 0,
                        totalXP: 0,
                        dimensions: [],
                        activities: [],
                        challenges: [],
                        rewards: {},
                        createdAt: new Date().toISOString()
                    };
                    await setDoc(userDocRef, window.userData);
                }
                console.log('User data loaded successfully');
            } catch (error) {
                console.error('Error loading user data:', error);
                // Initialize with default data if Firestore fails
                window.userData = {
                    level: 1,
                    currentXP: 0,
                    totalXP: 0,
                    dimensions: [],
                    activities: [],
                    challenges: [],
                    createdAt: new Date().toISOString()
                };
                throw error;
            }
        }

        // Update Dashboard
        function updateDashboard() {
            const data = window.userData;
            const level = Math.min(data.level || 1, 100); // enforce cap
            data.level = level;
            const currentXP = data.currentXP || 0;
            const isMaxLevel = level >= 100;
            const nextLevelXP = isMaxLevel ? 0 : calculateXPForLevel(level);
            const progress = isMaxLevel ? 100 : (currentXP / nextLevelXP) * 100;

            document.getElementById('currentLevel').textContent = level;
            document.getElementById('currentXP').textContent = isMaxLevel ? 'MAX' : currentXP;
            document.getElementById('progressBar').style.width = Math.min(progress, 100) + '%';
            const progressPctEl = document.getElementById('progressPercent');
            if (progressPctEl) progressPctEl.textContent = isMaxLevel ? '100%' : Math.floor(progress) + '%';

            // Above-bar right: XP to next (in green)
            const xpToNextDisp = document.getElementById('xpToNextDisplay');
            if (xpToNextDisp) {
                if (isMaxLevel) {
                    xpToNextDisp.textContent = 'Max!';
                } else {
                    const xpNeeded = Math.max(0, nextLevelXP - currentXP);
                    xpToNextDisp.textContent = xpNeeded;
                }
            }

            const today = new Date().toDateString();
            let completedToday = 0;
            let xpToday = 0;
            let longestStreak = 0;

            (data.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => {
                    (path.activities || []).forEach(activity => {
                        if (isCompletedToday(activity)) {
                            completedToday++;
                        }
                        // XP earned today from completionHistory
                        if (activity.completionHistory) {
                            activity.completionHistory.forEach(e => {
                                if (e.date && new Date(e.date).toDateString() === today) {
                                    xpToday += Math.abs(e.xp || 0);
                                }
                            });
                        }
                        // Track longest (all-time best) streak
                        const best = activity.bestStreak || activity.streak || 0;
                        if (best > longestStreak) longestStreak = best;
                    });
                });
            });

            document.getElementById('xpToday').textContent = xpToday;
            document.getElementById('completedToday').textContent = completedToday;
            document.getElementById('longestStreak').textContent = longestStreak;

            // Activity slot counter
            const { total: actTotal, limit: actLimit } = getActivityCounts();
            const slotEl = document.getElementById('activitySlotCount');
            if (slotEl) slotEl.textContent = `${actTotal}/${actLimit} slots`;

            renderDimensions();
            renderActivitiesList();
            renderChallenges();
            renderRewards();
            renderStreakPauseList();
        }

        // ── Activity Sort & Filter ────────────────────────────────────────
        const SORT_OPTIONS = [
            { id: 'grouped',     icon: '📋', label: 'Grouped by frequency' },
            { id: 'due-first',   icon: '🎯', label: 'Due today first' },
            { id: 'xp-high',     icon: '⬆️', label: 'Highest XP first' },
            { id: 'xp-low',      icon: '⬇️', label: 'Lowest XP first' },
            { id: 'streak-high', icon: '🔥', label: 'Longest streak first' },
            { id: 'alpha',       icon: '🔤', label: 'Alphabetical (A–Z)' },
        ];

        let _currentSort = null; // set on render

        function getCurrentSort() {
            return _currentSort || (window.userData.settings?.activitySort) || 'grouped';
        }

        window.toggleFilterPanel = function() {
            const panel = document.getElementById('filterPanel');
            const btn = document.getElementById('filterBtn');
            const isOpen = panel.style.display !== 'none';
            if (isOpen) {
                panel.style.display = 'none';
                btn.classList.remove('active');
            } else {
                renderFilterOptions();
                panel.style.display = 'block';
                btn.classList.add('active');
            }
        };

        function renderFilterOptions() {
            const current = getCurrentSort();
            const container = document.getElementById('filterOptions');
            if (!container) return;
            container.innerHTML = SORT_OPTIONS.map(o => `
                <button class="filter-option ${current === o.id ? 'selected' : ''}" onclick="applyActivitySort('${o.id}')">
                    <span class="fo-icon">${o.icon}</span>
                    ${o.label}
                    ${current === o.id ? '<svg style="margin-left:auto;flex-shrink:0;" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>' : ''}
                </button>
            `).join('');
        }

        window.applyActivitySort = function(sortId) {
            _currentSort = sortId;
            renderFilterOptions();
            // Update active dot
            const dot = document.getElementById('filterActiveDot');
            if (dot) dot.style.display = (sortId !== 'grouped') ? 'block' : 'none';
            renderActivitiesList();
        };

        window.setDefaultActivitySort = function() {
            const sort = getCurrentSort();
            if (!window.userData.settings) window.userData.settings = {};
            window.userData.settings.activitySort = sort;
            saveUserData();
            // Close panel
            const panel = document.getElementById('filterPanel');
            const btn = document.getElementById('filterBtn');
            if (panel) panel.style.display = 'none';
            if (btn) btn.classList.remove('active');
            showToast(`✓ "${SORT_OPTIONS.find(o=>o.id===sort)?.label}" set as default`, 'olive');
        };

        // Close filter panel when clicking outside
        document.addEventListener('click', function(e) {
            const btn = document.getElementById('filterBtn');
            const panel = document.getElementById('filterPanel');
            if (btn && panel && !btn.contains(e.target) && !panel.contains(e.target)) {
                panel.style.display = 'none';
                btn.classList.remove('active');
            }
        });

        // Render Activities List (flat view)
        function renderActivitiesList() {
            const container = document.getElementById('activitiesListContainer');
            const data = window.userData;
            let allActivities = [];

            // Collect all activities with their dimension and path info
            (data.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => {
                    (path.activities || []).forEach(activity => {
                        allActivities.push({
                            ...activity,
                            dimensionName: dim.name,
                            pathName: path.name,
                            dimensionId: dim.id,
                            pathId: path.id
                        });
                    });
                });
            });

            if (allActivities.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding: 60px 20px;">
                        <div class="empty-state-icon">🚀</div>
                        <p style="font-size:16px;font-weight:600;color:var(--color-text-primary);margin-bottom:8px;">Ready to level up your life?</p>
                        <p style="margin-bottom:24px;">Set up your first Dimension and Path, then add activities to start earning XP.</p>
                        <button class="cta-button" onclick="switchTab('dimensions')">🎯 &nbsp;Set up Dimensions</button>
                    </div>
                `;
                return;
            }

            // Initialise sort from stored preference on first render
            if (!_currentSort) {
                _currentSort = (window.userData.settings?.activitySort) || 'grouped';
                const dot = document.getElementById('filterActiveDot');
                if (dot) dot.style.display = (_currentSort !== 'grouped') ? 'block' : 'none';
            }

            const sort = getCurrentSort();

            if (sort === 'grouped') {
                // Group by frequency (original view)
                const groups = [
                    { key: 'daily',      label: 'Daily Activities',      activities: allActivities.filter(a => a.frequency === 'daily') },
                    { key: 'occasional', label: 'Occasional Activities',  activities: allActivities.filter(a => a.frequency === 'occasional' || a.frequency === 'one-time') },
                    { key: 'weekly',     label: 'Weekly Activities',      activities: allActivities.filter(a => a.frequency === 'weekly') },
                    { key: 'biweekly',   label: 'Bi-weekly Activities',   activities: allActivities.filter(a => a.frequency === 'biweekly') },
                    { key: 'monthly',    label: 'Monthly Activities',     activities: allActivities.filter(a => a.frequency === 'monthly') },
                    { key: 'custom',     label: 'Custom Interval',        activities: allActivities.filter(a => a.frequency === 'custom') },
                ].filter(g => g.activities.length > 0);

                if (!window.activityGroupExpanded) window.activityGroupExpanded = {};

                container.innerHTML = groups.map(g => {
                    const isExpanded = window.activityGroupExpanded[g.key] !== false;
                    return `
                    <div class="act-group" data-group="${g.key}">
                        <div class="act-group-header" onclick="toggleActivityGroup('${g.key}')">
                            <span class="collapse-icon ${isExpanded ? 'expanded' : ''}">▼</span>
                            <span class="act-group-label">${g.label}</span>
                            <span class="act-group-count">${g.activities.length}</span>
                        </div>
                        <div class="act-group-body ${isExpanded ? 'expanded' : ''}">
                            ${renderActivityCards(g.activities)}
                        </div>
                    </div>`;
                }).join('');
            } else {
                // Flat sorted list
                let sorted = [...allActivities];
                if (sort === 'due-first') {
                    // Incomplete activities first, then completed, both sorted by XP desc within group
                    sorted.sort((a, b) => {
                        const aDone = isCompletedToday(a) ? 1 : 0;
                        const bDone = isCompletedToday(b) ? 1 : 0;
                        if (aDone !== bDone) return aDone - bDone;
                        return (b.baseXP || 0) - (a.baseXP || 0);
                    });
                } else if (sort === 'xp-high') {
                    sorted.sort((a, b) => (b.baseXP || 0) - (a.baseXP || 0));
                } else if (sort === 'xp-low') {
                    sorted.sort((a, b) => (a.baseXP || 0) - (b.baseXP || 0));
                } else if (sort === 'streak-high') {
                    sorted.sort((a, b) => (b.streak || 0) - (a.streak || 0));
                } else if (sort === 'alpha') {
                    sorted.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                }
                const sortLabel = SORT_OPTIONS.find(o => o.id === sort)?.label || '';
                container.innerHTML = `
                    <div class="act-group">
                        <div class="act-group-header" style="cursor:default;pointer-events:none;">
                            <span class="act-group-label">${sortLabel}</span>
                            <span class="act-group-count">${sorted.length}</span>
                        </div>
                        <div class="act-group-body expanded">
                            ${renderActivityCards(sorted)}
                        </div>
                    </div>`;
            }
        }

        window.toggleActivityGroup = function(key) {
            if (!window.activityGroupExpanded) window.activityGroupExpanded = {};
            window.activityGroupExpanded[key] = window.activityGroupExpanded[key] === false ? true : false;
            renderActivitiesList();
        };

        // Update challenges on activity completion
        function updateChallengeProgress(activityId) {
            const challenges = window.userData.challenges || [];
            const today = new Date().toISOString().split('T')[0];
            
            challenges.forEach(challenge => {
                if (challenge.status !== 'active') return;
                
                // Check if challenge is within date range — if expired, just leave it as active
                // (user must manually complete or delete; no auto-fail)
                if (today < challenge.startDate || today > challenge.endDate) return;
                
                // Resolve which activity IDs count (support legacy single activityId)
                const challengeActivityIds = challenge.activityIds && challenge.activityIds.length > 0
                    ? challenge.activityIds
                    : (challenge.activityId ? [challenge.activityId] : []);

                const matchesActivity = challengeActivityIds.length === 0 || challengeActivityIds.includes(activityId);
                if (!matchesActivity) return;

                // Per-activity target tracking
                if (challengeActivityIds.length > 0 && challenge.activityTargets && challenge.activityTargets[activityId] !== undefined) {
                    if (!challenge.activityProgress) challenge.activityProgress = {};
                    challenge.activityProgress[activityId] = (challenge.activityProgress[activityId] || 0) + 1;
                    // Recompute overall currentCount as sum of capped per-activity progress
                    challenge.currentCount = challengeActivityIds.reduce((sum, id) => {
                        const target = challenge.activityTargets[id] || 1;
                        return sum + Math.min(challenge.activityProgress[id] || 0, target);
                    }, 0);
                } else {
                    challenge.currentCount++;
                }
                // Note: challenges only complete via the "Complete" button — never auto-complete here
            });
        }

        // Reverse one completion unit for a given activity across all active challenges
        function undoChallengeProgress(activityId) {
            const challenges = window.userData.challenges || [];
            const today = new Date().toISOString().split('T')[0];
            challenges.forEach(challenge => {
                if (challenge.status !== 'active') return;
                if (today < challenge.startDate || today > challenge.endDate) return;
                const challengeActivityIds = challenge.activityIds && challenge.activityIds.length > 0
                    ? challenge.activityIds
                    : (challenge.activityId ? [challenge.activityId] : []);
                const matchesActivity = challengeActivityIds.length === 0 || challengeActivityIds.includes(activityId);
                if (!matchesActivity) return;
                if (challengeActivityIds.length > 0 && challenge.activityTargets && challenge.activityTargets[activityId] !== undefined) {
                    if (challenge.activityProgress && challenge.activityProgress[activityId] > 0) {
                        challenge.activityProgress[activityId]--;
                    }
                    challenge.currentCount = challengeActivityIds.reduce((sum, id) => {
                        const target = challenge.activityTargets[id] || 1;
                        return sum + Math.min((challenge.activityProgress || {})[id] || 0, target);
                    }, 0);
                } else {
                    challenge.currentCount = Math.max(0, (challenge.currentCount || 0) - 1);
                }
            });
        }

        function showChallengeCompleteToast(challengeName, bonusXP) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: var(--color-accent-olive);
                color: var(--color-text-primary);
                padding: 16px 24px;
                border-radius: 12px;
                font-weight: 600;
                font-size: 16px;
                z-index: 10000;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
                animation: slideIn 0.3s ease;
            `;
            
            toast.textContent = `🏆 Challenge Complete: ${challengeName} • +${bonusXP} XP`;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        function renderActivityCards(activities) {
            // Build a set of activity IDs that are part of active challenges
            const challengeActivityIds = new Set();
            (window.userData.challenges || []).forEach(ch => {
                if (ch.status !== 'active') return;
                (ch.activityIds || (ch.activityId ? [ch.activityId] : [])).forEach(id => challengeActivityIds.add(id));
            });

            return activities.map(activity => {
                const completedToday = isCompletedToday(activity);
                const canComplete = canCompleteActivity(activity);
                const inChallenge = challengeActivityIds.has(activity.id);
                const allowMulti = activity.allowMultiplePerDay && activity.frequency !== 'occasional';

                // Compute the XP the user would earn right now (including streak bonus)
                const isOccasional = activity.frequency === 'occasional';
                const isSkipMode = !!activity.isSkipNegative;
                const currentStreak = isOccasional ? 0 : (activity.streak || 0);
                const previewStreak = completedToday ? currentStreak : currentStreak + 1;
                const mult = isOccasional ? 1 : calculateConsistencyMultiplier(previewStreak);
                const displayXP = Math.floor(activity.baseXP * mult);
                const showBonus = mult > 1;

                // Custom activity: counter badge and non-scheduled day greying
                let counterBadge = '';
                let notScheduledToday = false;
                if (activity.frequency === 'custom') {
                    const done = cycleCompletionsNow(activity);
                    const needed = activity.timesPerCycle || 1;
                    counterBadge = `<span class="activity-badge badge-counter">${done}/${needed}</span>`;
                    if (activity.customSubtype === 'days' && !isScheduledDay(activity)) {
                        notScheduledToday = true;
                    }
                }

                // Multi-complete: show today's count as a badge
                if (allowMulti) {
                    const todayCount = countCompletionsToday(activity);
                    if (todayCount > 0) {
                        counterBadge = `<span class="activity-badge badge-counter">×${todayCount} today</span>`;
                    }
                }

                let clickHandler, itemClass;
                if (notScheduledToday) {
                    clickHandler = 'void(0)';
                    itemClass = 'disabled';
                } else if (allowMulti) {
                    // Multi-complete: card always clickable to log another; completed style only after ≥1 today
                    clickHandler = `completeActivityById('${activity.id}')`;
                    itemClass = completedToday ? 'completed-multi' : (isSkipMode ? 'skip-mode-pending' : '');
                } else if (completedToday) {
                    // Once-per-day completed: card non-clickable, undo button shown
                    clickHandler = 'void(0)';
                    itemClass = 'completed';
                } else if (canComplete) {
                    clickHandler = `completeActivityById('${activity.id}')`;
                    itemClass = isSkipMode ? 'skip-mode-pending' : '';
                } else {
                    clickHandler = 'void(0)';
                    itemClass = 'disabled';
                }

                // Undo button: shown when there are completions today
                const todayCount = allowMulti ? countCompletionsToday(activity) : 0;
                const showUndo = allowMulti
                    ? todayCount > 0
                    : (completedToday && !notScheduledToday);
                const undoLabel = allowMulti ? '↩ Undo' : '↩ Undo';
                const undoBtn = showUndo
                    ? `<button class="btn-undo-activity" onclick="event.stopPropagation();undoActivityById('${activity.id}')" title="Undo last completion">${undoLabel}</button>`
                    : '';

                // XP badge label
                let xpBadgeLabel, xpBadgeClass;
                if (isSkipMode) {
                    xpBadgeLabel = completedToday
                        ? `+${displayXP} XP earned`
                        : `+${displayXP} XP (skip = −${activity.baseXP})`;
                    xpBadgeClass = 'badge-xp';
                } else {
                    xpBadgeLabel = `${activity.isNegative ? '−' : '+'}${displayXP} XP${showBonus ? ` <span style="opacity:0.75;font-size:10px;">(${mult}×)</span>` : ''}`;
                    xpBadgeClass = activity.isNegative ? 'badge-negative' : 'badge-xp';
                }

                return `
                <div class="activity-item ${itemClass}" onclick="${clickHandler}">
                    <div class="activity-info-container">
                        <div class="activity-name">${escapeHtml(activity.name)}</div>
                        <div class="activity-details">
                            <span class="activity-badge badge-frequency">
                                ${activity.dimensionName} › ${activity.pathName}
                            </span>
                            <span class="activity-badge ${xpBadgeClass}" title="${showBonus ? `${mult}× streak bonus` : ''}">
                                ${xpBadgeLabel}
                            </span>
                            ${currentStreak > 0 ? `<span class="activity-badge badge-streak">🔥 ${currentStreak}</span>` : ''}
                            ${counterBadge}
                            ${inChallenge ? `<span class="activity-badge" style="background:rgba(122,123,77,0.18);color:var(--color-accent-olive);border:1px solid rgba(122,123,77,0.35);">🏅 Challenge</span>` : ''}
                        </div>
                    </div>
                    <div style="display:flex;align-items:center;gap:6px;flex-shrink:0;">
                        ${undoBtn}
                        <div class="activity-check">✓</div>
                    </div>
                </div>
            `}).join('');
        }

        // Complete activity by ID (for flat activities view)
        window.completeActivityById = async function(activityId) {
            const data = window.userData;
            
            // Find the activity
            for (let dimIndex = 0; dimIndex < (data.dimensions || []).length; dimIndex++) {
                const dim = data.dimensions[dimIndex];
                for (let pathIndex = 0; pathIndex < (dim.paths || []).length; pathIndex++) {
                    const path = dim.paths[pathIndex];
                    const actIndex = (path.activities || []).findIndex(a => a.id === activityId);
                    if (actIndex !== -1) {
                        await completeActivity(dimIndex, pathIndex, actIndex);
                        return;
                    }
                }
            }
        };

        // Undo activity by ID (for flat activities view)
        window.undoActivityById = async function(activityId) {
            const data = window.userData;
            
            // Find the activity
            for (let dimIndex = 0; dimIndex < (data.dimensions || []).length; dimIndex++) {
                const dim = data.dimensions[dimIndex];
                for (let pathIndex = 0; pathIndex < (dim.paths || []).length; pathIndex++) {
                    const path = dim.paths[pathIndex];
                    const actIndex = (path.activities || []).findIndex(a => a.id === activityId);
                    if (actIndex !== -1) {
                        await undoActivity(dimIndex, pathIndex, actIndex);
                        return;
                    }
                }
            }
        };

        // Calculate activity limit based on level: 2^(x-1) + 3, capped at 250
        // L1: 4, L2: 5, L3: 7, L4: 11, L5: 19, L6: 35 … L8: 131, L9: 259→capped at 250
        function getActivityLimit(level) {
            return Math.min(250, Math.pow(2, level - 1) + 3);
        }

        // Check if user can add more activities
        function canAddActivity() {
            const level = window.userData.level || 1;
            let totalActivities = 0;
            (window.userData.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => {
                    totalActivities += (path.activities || []).length;
                });
            });
            return totalActivities < getActivityLimit(level);
        }

        function getActivityCounts() {
            let total = 0;
            (window.userData.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => { total += (path.activities || []).length; });
            });
            const level = window.userData.level || 1;
            const limit = getActivityLimit(level);
            return { total, limit };
        }

        // Render Dimensions
        function renderDimensions() {
            const container = document.getElementById('dimensionsContainer');
            const dimensions = window.userData.dimensions || [];

            if (dimensions.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🎯</div>
                        <p>No dimensions yet. Create your first dimension to get started!</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = dimensions.map((dim, dimIndex) => `
                <div class="dimension-card">
                    <div class="dimension-header" onclick="toggleDimension(${dimIndex})">
                        <span class="collapse-icon ${dim.expanded ? 'expanded' : ''}">▼</span>
                        <div class="dimension-info">
                            <div class="dimension-name">${escapeHtml(dim.name)}</div>
                            <div class="dimension-meta">${(dim.paths || []).length} paths • ${countDimensionActivities(dim)} activities</div>
                        </div>
                        <div class="dimension-actions" onclick="event.stopPropagation()">
                            <button class="btn-icon" onclick="openPathModal(${dimIndex})">+ Path</button>
                            <button class="btn-icon" onclick="editDimension(${dimIndex})">Edit</button>
                            <button class="btn-icon delete" onclick="deleteDimension(${dimIndex})">Delete</button>
                        </div>
                    </div>
                    <div class="dimension-content ${dim.expanded ? 'expanded' : ''}">
                        ${renderPaths(dim.paths || [], dimIndex)}
                    </div>
                </div>
            `).join('');
        }

        function countDimensionActivities(dimension) {
            let count = 0;
            (dimension.paths || []).forEach(path => {
                count += (path.activities || []).length;
            });
            return count;
        }

        function renderPaths(paths, dimIndex) {
            if (paths.length === 0) {
                return '<div class="empty-state"><p>No paths yet. Click "+ Path" to add one.</p></div>';
            }

            return paths.map((path, pathIndex) => `
                <div class="path-card">
                    <div class="path-header" onclick="togglePath(${dimIndex}, ${pathIndex})">
                        <span class="collapse-icon ${path.expanded ? 'expanded' : ''}">▼</span>
                        <div style="flex:1;min-width:0;">
                            <div class="path-name">${escapeHtml(path.name)}</div>
                            <div style="font-size: 12px; color: var(--color-text-secondary); margin-top: 2px;">
                                ${(path.activities || []).length} activities
                            </div>
                        </div>
                        <div class="dimension-actions" onclick="event.stopPropagation()">
                            <button class="btn-icon" onclick="openActivityModal(${dimIndex}, ${pathIndex})">+ Activity</button>
                            <button class="btn-icon" onclick="editPath(${dimIndex}, ${pathIndex})">Edit</button>
                            <button class="btn-icon delete" onclick="deletePath(${dimIndex}, ${pathIndex})">Delete</button>
                        </div>
                    </div>
                    <div class="path-content ${path.expanded ? 'expanded' : ''}">
                        ${renderActivities(path.activities || [], dimIndex, pathIndex)}
                    </div>
                </div>
            `).join('');
        }

        // Challenge Modal Functions
        let editingChallengeIndex = null;

        window.toggleMetricSection = function() {
            const hiddenInput = document.getElementById('challengeMetricEnabled');
            const grp = document.getElementById('challengeMetricGroup');
            const btn = document.getElementById('metricToggleBtn');
            const check = document.getElementById('metricToggleCheck');
            if (!hiddenInput || !grp) return;
            const isActive = hiddenInput.value === '1';
            const newActive = !isActive;
            hiddenInput.value = newActive ? '1' : '0';
            grp.style.display = newActive ? 'block' : 'none';
            if (btn) btn.classList.toggle('active', newActive);
            if (check) check.textContent = newActive ? '✓' : '';
        };

        window.onChallengeTypeChange = function() {
            const isSpecific = document.getElementById('challengeActivityType').value === 'specific';
            document.getElementById('challengeActivitySelectGroup').style.display = isSpecific ? 'block' : 'none';
            document.getElementById('challengeGlobalTargetRow').style.display = isSpecific ? 'none' : 'grid';
            const xpSpecific = document.getElementById('challengeXPSpecific');
            if (xpSpecific) xpSpecific.required = isSpecific;
            document.getElementById('challengeXP').required = !isSpecific;
        };

        window.openChallengeModal = function(index = null) {
            editingChallengeIndex = index;
            const modal = document.getElementById('challengeModal');
            const title = document.getElementById('challengeModalTitle');
            const submitBtn = document.getElementById('challengeSubmitBtn');

            if (index !== null) {
                title.textContent = 'Edit Challenge';
                if (submitBtn) submitBtn.textContent = 'Save Challenge';
                const challenge = window.userData.challenges[index];
                const selectedIds = challenge.activityIds || (challenge.activityId ? [challenge.activityId] : []);
                const activityTargets = challenge.activityTargets || {};
                populateChallengeActivitySelect(selectedIds, activityTargets);
                document.getElementById('challengeName').value = challenge.name;
                document.getElementById('challengeDescription').value = challenge.description || '';
                document.getElementById('challengeStartDate').value = challenge.startDate;
                document.getElementById('challengeEndDate').value = challenge.endDate;
                const hasSpecific = selectedIds.length > 0;
                document.getElementById('challengeActivityType').value = hasSpecific ? 'specific' : 'any';
                onChallengeTypeChange();
                if (!hasSpecific) {
                    document.getElementById('challengeXP').value = challenge.bonusXP;
                } else {
                    const xpSpecific = document.getElementById('challengeXPSpecific');
                    if (xpSpecific) xpSpecific.value = challenge.bonusXP;
                }
                // Metric
                const metricEnabled = !!(challenge.metricEnabled && challenge.metricQty && challenge.metricUnit);
                const hiddenMetric = document.getElementById('challengeMetricEnabled');
                const metricBtn = document.getElementById('metricToggleBtn');
                const metricCheck = document.getElementById('metricToggleCheck');
                if (hiddenMetric) hiddenMetric.value = metricEnabled ? '1' : '0';
                if (metricBtn) metricBtn.classList.toggle('active', metricEnabled);
                if (metricCheck) metricCheck.textContent = metricEnabled ? '✓' : '';
                document.getElementById('challengeMetricGroup').style.display = metricEnabled ? 'block' : 'none';
                if (metricEnabled) {
                    document.getElementById('challengeMetricQty').value = challenge.metricQty;
                    document.getElementById('challengeMetricUnit').value = challenge.metricUnit;
                }
            } else {
                title.textContent = 'Create Challenge';
                if (submitBtn) submitBtn.textContent = 'Create Challenge';
                populateChallengeActivitySelect([], {});
                document.getElementById('challengeForm').reset();
                const _hm = document.getElementById('challengeMetricEnabled');
                const _mb = document.getElementById('metricToggleBtn');
                const _mc = document.getElementById('metricToggleCheck');
                if (_hm) _hm.value = '0';
                if (_mb) _mb.classList.remove('active');
                if (_mc) _mc.textContent = '';
                document.getElementById('challengeMetricGroup').style.display = 'none';
                onChallengeTypeChange();
                const today = new Date().toISOString().split('T')[0];
                const nextMonth = new Date();
                nextMonth.setMonth(nextMonth.getMonth() + 1);
                document.getElementById('challengeStartDate').value = today;
                document.getElementById('challengeEndDate').value = nextMonth.toISOString().split('T')[0];
            }
            
            modal.classList.add('active');
        };

        window.closeChallengeModal = function() {
            document.getElementById('challengeModal').classList.remove('active');
            editingChallengeIndex = null;
        };

        function populateChallengeActivitySelect(selectedIds = [], activityTargets = {}) {
            const checklist = document.getElementById('challengeActivityChecklist');
            const emptyMsg = document.getElementById('challengeActivityChecklistEmpty');
            checklist.innerHTML = '';

            let allActivities = [];
            (window.userData.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => {
                    (path.activities || []).forEach(activity => {
                        allActivities.push({
                            id: activity.id,
                            name: activity.name,
                            path: `${dim.name} → ${path.name}`
                        });
                    });
                });
            });

            if (allActivities.length === 0) {
                emptyMsg.style.display = 'block';
                return;
            }
            emptyMsg.style.display = 'none';

            allActivities.forEach(activity => {
                const item = document.createElement('div');
                const isChecked = selectedIds.includes(activity.id);
                item.className = `activity-checklist-item${isChecked ? ' checked' : ''}`;
                const checkId = `challenge-activity-${activity.id}`;
                const targetInputId = `challenge-target-${activity.id}`;
                const savedTarget = activityTargets[activity.id] || 1;
                item.innerHTML = `
                    <input type="checkbox" id="${checkId}" value="${activity.id}" ${isChecked ? 'checked' : ''}>
                    <label for="${checkId}">
                        ${escapeHtml(activity.name)}
                        <span>${escapeHtml(activity.path)}</span>
                    </label>
                    <div class="target-input-wrap">
                        <input type="number" id="${targetInputId}" value="${savedTarget}" min="1" placeholder="1" onclick="event.stopPropagation()">
                        <label style="cursor:default;">times</label>
                    </div>
                `;
                // Toggle checked class & target input visibility on checkbox change
                const checkbox = item.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        item.classList.add('checked');
                    } else {
                        item.classList.remove('checked');
                    }
                });
                checklist.appendChild(item);
            });
        }

        function getSelectedChallengeActivitiesWithTargets() {
            const items = document.querySelectorAll('#challengeActivityChecklist .activity-checklist-item');
            const result = { activityIds: [], activityTargets: {} };
            items.forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                if (checkbox && checkbox.checked) {
                    const id = checkbox.value;
                    const targetInput = item.querySelector(`#challenge-target-${id}`);
                    const target = targetInput ? Math.max(1, parseInt(targetInput.value) || 1) : 1;
                    result.activityIds.push(id);
                    result.activityTargets[id] = target;
                }
            });
            return result;
        }

        // Keep legacy helper for compatibility
        function getSelectedChallengeActivityIds() {
            return getSelectedChallengeActivitiesWithTargets().activityIds;
        }

        window.saveChallenge = async function(event) {
            event.preventDefault();
            
            const name = document.getElementById('challengeName').value;
            const description = document.getElementById('challengeDescription').value;
            const bonusXPEl = document.getElementById('challengeXP');
            const bonusXPSpecificEl = document.getElementById('challengeXPSpecific');
            const startDate = document.getElementById('challengeStartDate').value;
            const endDate = document.getElementById('challengeEndDate').value;
            const activityType = document.getElementById('challengeActivityType').value;

            // Metric
            const metricEnabled = document.getElementById('challengeMetricEnabled').value === '1';
            const metricQty = metricEnabled ? parseFloat(document.getElementById('challengeMetricQty').value) : null;
            const metricUnit = metricEnabled ? document.getElementById('challengeMetricUnit').value.trim() : null;
            if (metricEnabled && (!metricQty || !metricUnit)) {
                alert('Please fill in both Quantity and Unit for the goal metric, or uncheck it.'); return;
            }

            let activityIds = [];
            let activityTargets = {};
            let targetCount;
            let bonusXP;

            if (activityType === 'specific') {
                const selected = getSelectedChallengeActivitiesWithTargets();
                activityIds = selected.activityIds;
                activityTargets = selected.activityTargets;
                if (activityIds.length === 0) { alert('Please select at least one activity.'); return; }
                targetCount = Object.values(activityTargets).reduce((a, b) => a + b, 0);
                bonusXP = parseInt(bonusXPSpecificEl ? bonusXPSpecificEl.value : bonusXPEl.value);
            } else {
                // For any-activity: targetCount is not meaningful for display, set to 0
                targetCount = 0;
                bonusXP = parseInt(bonusXPEl.value);
            }

            if (!bonusXP || bonusXP < 1) { alert('Please enter a Bonus XP value.'); return; }
            
            if (editingChallengeIndex !== null) {
                const challenge = window.userData.challenges[editingChallengeIndex];
                challenge.name = name;
                challenge.description = description;
                challenge.targetCount = targetCount;
                challenge.bonusXP = bonusXP;
                challenge.startDate = startDate;
                challenge.endDate = endDate;
                challenge.activityIds = activityIds;
                challenge.activityTargets = activityTargets;
                challenge.activityId = null;
                challenge.metricQty = metricQty;
                challenge.metricUnit = metricUnit;
                challenge.metricEnabled = metricEnabled;
                if (!challenge.activityProgress) challenge.activityProgress = {};
            } else {
                if (!window.userData.challenges) window.userData.challenges = [];
                const activityProgress = {};
                activityIds.forEach(id => { activityProgress[id] = 0; });
                window.userData.challenges.push({
                    id: Date.now().toString(),
                    name, description, targetCount, bonusXP,
                    startDate, endDate, activityIds, activityTargets, activityProgress,
                    activityId: null, currentCount: 0,
                    metricEnabled, metricQty, metricUnit, metricCurrent: 0,
                    activityProgressCollapsed: true,
                    status: 'active',
                    createdAt: new Date().toISOString()
                });
            }
            
            await saveUserData();
            closeChallengeModal();
            updateDashboard();
        };

        window.completeChallenge = async function(index) {
            const challenge = window.userData.challenges[index];
            if (!challenge || challenge.status !== 'active') return;
            if (!confirm(`Mark "${challenge.name}" as completed? You'll earn the full ${challenge.bonusXP} XP bonus.`)) return;

            challenge.status = 'completed';
            challenge.currentCount = challenge.targetCount; // show full progress bar
            window.userData.currentXP += challenge.bonusXP;
            window.userData.totalXP += challenge.bonusXP;

            // Check for level up
            let level = window.userData.level || 1;
            let xpForNext = calculateXPForLevel(level);
            let didLevelUp = false;
            while (window.userData.currentXP >= xpForNext && level < 100) {
                window.userData.currentXP -= xpForNext;
                window.userData.level++;
                level = window.userData.level;
                xpForNext = calculateXPForLevel(level);
                didLevelUp = true;
            }
            if (window.userData.level >= 100) window.userData.level = 100;
            if (didLevelUp) showLevelUpAnimation();

            showChallengeCompleteToast(challenge.name, challenge.bonusXP);
            await saveUserData();
            updateDashboard();
        };

        window.undoChallenge = async function(index) {
            const challenge = window.userData.challenges[index];
            if (!challenge || challenge.status !== 'completed') return;
            if (!confirm(`Undo completion of "${challenge.name}"? The ${challenge.bonusXP} XP bonus will be returned.`)) return;

            challenge.status = 'active';
            // Reset currentCount so the "all targets met" banner doesn't immediately reappear.
            // Count actual completions from activityProgress if available, else set to 0.
            if (challenge.activityProgress && Object.keys(challenge.activityProgress).length > 0) {
                challenge.currentCount = Object.values(challenge.activityProgress).reduce((a, b) => a + b, 0);
            } else {
                challenge.currentCount = 0;
            }
            window.userData.currentXP -= challenge.bonusXP;
            window.userData.totalXP -= challenge.bonusXP;

            // Handle level-down if XP went negative
            while (window.userData.currentXP < 0 && window.userData.level > 1) {
                window.userData.level -= 1;
                window.userData.currentXP += calculateXPForLevel(window.userData.level);
            }
            if (window.userData.currentXP < 0) window.userData.currentXP = 0;

            await saveUserData();
            updateDashboard();
            showToast(`↩ Challenge un-completed — ${challenge.bonusXP} XP returned`, 'olive');
        };

        window.editChallenge = function(index) {
            openChallengeModal(index);
        };

        window.deleteChallenge = async function(index) {
            if (confirm('Delete this challenge?')) {
                window.userData.challenges.splice(index, 1);
                await saveUserData();
                updateDashboard();
            }
        };

        // Challenge activity type handled by onChallengeTypeChange()

        // Render Challenges
        function renderChallenges() {
            const container = document.getElementById('challengesContainer');
            const challenges = window.userData.challenges || [];

            if (challenges.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🏆</div>
                        <p>No challenges yet. Create your first challenge to earn bonus XP!</p>
                    </div>
                `;
                return;
            }

            const activeChallenges = challenges.filter(c => c.status === 'active');
            const completedChallenges = challenges.filter(c => c.status === 'completed');
            const failedChallenges = challenges.filter(c => c.status === 'failed');

            let html = '';

            if (activeChallenges.length > 0) {
                html += `<h3 style="margin: 24px 0 12px 0; font-size: 18px;">Active Challenges</h3>`;
                html += activeChallenges.map(challenge => renderChallengeCard(challenge, challenges.indexOf(challenge))).join('');
            }

            if (completedChallenges.length > 0) {
                html += `<h3 style="margin: 24px 0 12px 0; font-size: 18px;">Completed</h3>`;
                html += completedChallenges.map(challenge => renderChallengeCard(challenge, challenges.indexOf(challenge))).join('');
            }

            if (failedChallenges.length > 0) {
                html += `<h3 style="margin: 24px 0 12px 0; font-size: 18px;">Failed</h3>`;
                html += failedChallenges.map(challenge => renderChallengeCard(challenge, challenges.indexOf(challenge))).join('');
            }

            container.innerHTML = html;
        }

        window.updateMetricProgress = async function(challengeId) {
            const challenges = window.userData.challenges || [];
            const challenge = challenges.find(c => c.id === challengeId);
            if (!challenge) return;
            const inputEl = document.getElementById('metric-input-' + challengeId);
            if (!inputEl) return;
            const val = parseFloat(inputEl.value);
            if (isNaN(val) || val < 0) { showToast('Enter a valid number', 'red'); return; }
            challenge.metricCurrent = val;
            await saveUserData();
            updateDashboard();
            showToast('✓ Progress updated', 'olive');
        };

        window.toggleActivityProgress = function(challengeId) {
            const body = document.getElementById('ch-breakdown-' + challengeId);
            const icon = document.getElementById('ch-breakdown-icon-' + challengeId);
            if (!body) return;
            const isNowCollapsed = body.classList.toggle('collapsed');
            // Drive the max-height for smooth animation
            body.style.maxHeight = isNowCollapsed ? '0' : (body.scrollHeight + 60) + 'px';
            if (icon) icon.textContent = isNowCollapsed ? '▶' : '▼';
            const challenges = window.userData.challenges || [];
            const ch = challenges.find(c => c.id === challengeId);
            if (ch) { ch.activityProgressCollapsed = isNowCollapsed; saveUserData(); }
        };

        function renderChallengeCard(challenge, index) {
            const isActive   = challenge.status === 'active';
            const isCompleted = challenge.status === 'completed';
            const isFailed   = challenge.status === 'failed';
            const daysLeft   = Math.ceil((new Date(challenge.endDate) - new Date()) / (1000 * 60 * 60 * 24));

            // Name map
            const nameMap = {};
            (window.userData.dimensions || []).forEach(dim =>
                (dim.paths || []).forEach(path =>
                    (path.activities || []).forEach(act => { nameMap[act.id] = act.name; })));

            const challengeActivityIds = challenge.activityIds && challenge.activityIds.length > 0
                ? challenge.activityIds
                : (challenge.activityId ? [challenge.activityId] : []);

            const hasPerActivity = challengeActivityIds.length > 0
                && challenge.activityTargets && Object.keys(challenge.activityTargets).length > 0;
            const hasMetric = !!(challenge.metricEnabled && challenge.metricQty && challenge.metricUnit);

            // Compute activity progress
            let activityPct = 0;
            let activityRowsHtml = '';
            if (hasPerActivity) {
                const totalTarget  = challengeActivityIds.reduce((s, id) => s + (challenge.activityTargets[id] || 1), 0);
                const totalCurrent = challengeActivityIds.reduce((s, id) =>
                    s + Math.min((challenge.activityProgress || {})[id] || 0, challenge.activityTargets[id] || 1), 0);
                activityPct = totalTarget > 0 ? Math.min(100, (totalCurrent / totalTarget) * 100) : 0;

                activityRowsHtml = challengeActivityIds.map(id => {
                    const target  = challenge.activityTargets[id] || 1;
                    const current = Math.min((challenge.activityProgress || {})[id] || 0, target);
                    const pct     = Math.min(100, (current / target) * 100);
                    const done    = current >= target;
                    const barFill = done ? 'var(--color-accent-green)'
                        : isCompleted ? 'var(--color-accent-green)'
                        : isFailed ? 'var(--color-accent-red)' : 'var(--color-accent-blue)';
                    return `
                        <div class="ch-act-row"><span class="ch-act-row-name${done?' done':''}">${done?'✓ ':''}${escapeHtml(nameMap[id]||id)}</span><span class="ch-act-row-count">${current}/${target}</span></div>
                        <div class="ch-act-bar-track"><div class="ch-bar-fill" style="width:${pct}%;background:${barFill};"></div></div>`;
                }).join('');
            }

            const allTargetsMet = isActive && hasPerActivity && activityPct >= 100;
            const barMainColor  = isCompleted ? 'var(--color-accent-green)'
                : isFailed ? 'var(--color-accent-red)'
                : allTargetsMet ? 'var(--color-accent-green)' : 'var(--color-accent-blue)';

            // ── Progress HTML ──────────────────────────────────────────────
            let progressHtml = '';

            if (hasMetric) {
                const metricCurrent = challenge.metricCurrent || 0;
                const metricPct = Math.min(100, (metricCurrent / challenge.metricQty) * 100);
                const metricFill = metricPct >= 100 ? 'var(--color-accent-green)' : barMainColor;

                progressHtml += `
                <div class="ch-progress-block">
                    <div class="ch-progress-label">
                        <span class="ch-progress-label-name">🎯 ${escapeHtml(challenge.metricUnit)} goal</span>
                        <span class="ch-progress-label-val">${metricCurrent} / ${challenge.metricQty} ${escapeHtml(challenge.metricUnit)}&nbsp;&nbsp;${Math.floor(metricPct)}%</span>
                    </div>
                    <div class="ch-bar-track"><div class="ch-bar-fill" style="width:${metricPct}%;background:${metricFill};"></div></div>
                    ${isActive ? `
                    <div class="ch-update-row">
                        <input class="ch-update-input" type="number" id="metric-input-${challenge.id}" placeholder="Current value" step="any" min="0" value="${metricCurrent > 0 ? metricCurrent : ''}">
                        <button type="button" class="ch-update-btn" onclick="updateMetricProgress('${challenge.id}')">Update</button>
                    </div>` : ''}
                </div>`;

                if (hasPerActivity) {
                    const collapsed = challenge.activityProgressCollapsed !== false;
                    progressHtml += `
                <div class="ch-breakdown-toggle" onclick="toggleActivityProgress('${challenge.id}')">
                    <span>📋 Activity breakdown &nbsp;<span style="color:var(--color-accent-blue);font-weight:600;">${Math.floor(activityPct)}%</span></span>
                    <span id="ch-breakdown-icon-${challenge.id}">${collapsed ? '▶' : '▼'}</span>
                </div>
                <div class="ch-breakdown-body${collapsed ? ' collapsed' : ''}" id="ch-breakdown-${challenge.id}" style="max-height:${collapsed ? '0' : '600px'};">
                    <div style="padding-top:10px;">${activityRowsHtml}</div>
                </div>`;
                }

            } else if (hasPerActivity) {
                // No metric: activity bars ARE the main progress
                progressHtml += `
                <div class="ch-progress-block">
                    <div class="ch-progress-label">
                        <span class="ch-progress-label-name">Progress</span>
                        <span class="ch-progress-label-val">${Math.floor(activityPct)}%</span>
                    </div>
                    <div class="ch-bar-track"><div class="ch-bar-fill" style="width:${activityPct}%;background:${barMainColor};"></div></div>
                </div>
                <div style="margin-bottom:4px;">${activityRowsHtml}</div>`;

            } else {
                // Any-activity, no metric
                const anyCount = challenge.currentCount || 0;
                progressHtml += `
                <div class="ch-progress-block">
                    <div class="ch-progress-label">
                        <span class="ch-progress-label-name">Completions</span>
                        <span class="ch-progress-label-val">${anyCount} activities done</span>
                    </div>
                    <div class="ch-bar-track"><div class="ch-bar-fill" style="width:${isCompleted?100:0}%;background:var(--color-accent-green);"></div></div>
                </div>`;
            }

            // ── Card class ─────────────────────────────────────────────────
            const cardClass = isCompleted ? 'challenge-card completed'
                : isFailed ? 'challenge-card failed'
                : allTargetsMet ? 'challenge-card targets-met'
                : 'challenge-card';

            // ── Ready banner ───────────────────────────────────────────────
            const readyBanner = allTargetsMet ? `
                <div class="ch-ready-banner">🎯 <strong>All targets met!</strong>&nbsp; Click "Complete" to claim your bonus.</div>` : '';

            // ── Activity badge ─────────────────────────────────────────────
            const actBadge = challengeActivityIds.length === 0 ? '' :
                `<span class="activity-badge" style="background:rgba(74,124,158,0.15);color:var(--color-accent-blue);" title="${escapeHtml(challengeActivityIds.map(id=>nameMap[id]||id).join(', '))}">📌 ${challengeActivityIds.length} activit${challengeActivityIds.length===1?'y':'ies'}</span>`;

            return `
                <div class="${cardClass}">
                    <div class="ch-header">
                        <div style="flex:1;min-width:0;">
                            <h3 class="ch-title">${escapeHtml(challenge.name)}</h3>
                            ${challenge.description ? `<p class="ch-desc">${escapeHtml(challenge.description)}</p>` : ''}
                        </div>
                        <div class="ch-actions">
                            ${isActive ? `
                                <button class="btn-complete-challenge${allTargetsMet?' btn-complete-ready':''}" onclick="completeChallenge(${index})">✓ Complete</button>
                                <button class="btn-icon" onclick="editChallenge(${index})">Edit</button>
                                <button class="btn-icon delete" onclick="deleteChallenge(${index})">✕</button>
                            ` : isCompleted ? `
                                <button class="btn-icon" onclick="undoChallenge(${index})" style="border-color:var(--color-accent-red);color:#e07070;" title="Undo">↩</button>
                            ` : ''}
                        </div>
                    </div>

                    ${readyBanner}
                    ${progressHtml}

                    <div class="ch-tags">
                        <span class="activity-badge badge-xp">+${challenge.bonusXP} XP</span>
                        ${isActive ? `<span class="activity-badge badge-frequency">${daysLeft > 0 ? daysLeft + ' days left' : 'Ends today'}</span>` : ''}
                        ${hasMetric ? `<span class="activity-badge" style="background:rgba(90,159,212,0.12);color:var(--color-progress);">🎯 ${challenge.metricQty} ${escapeHtml(challenge.metricUnit)}</span>` : ''}
                        ${actBadge}
                        ${isCompleted ? `<span class="activity-badge" style="background:rgba(107,124,63,0.2);color:var(--color-accent-green);">✓ Completed</span>` : ''}
                        ${isFailed ? `<span class="activity-badge badge-negative">✗ Failed</span>` : ''}
                    </div>
                </div>
            `;
        }


                function renderActivities(activities, dimIndex, pathIndex) {
            if (activities.length === 0) {
                return '<div class="empty-state"><p>No activities yet. Click "+ Activity" to add one.</p></div>';
            }

            const freqLabel = { daily:'Daily', occasional:'Occasional', weekly:'Weekly', biweekly:'Bi-weekly', monthly:'Monthly', custom:'Custom', 'one-time':'Occasional' };

            return activities.map((activity, actIndex) => {
                const completedToday = isCompletedToday(activity);
                const canComplete = canCompleteActivity(activity);
                const allowMulti = activity.allowMultiplePerDay && activity.frequency !== 'occasional';

                let clickHandler, itemClass;
                if (allowMulti) {
                    clickHandler = `completeActivity(${dimIndex}, ${pathIndex}, ${actIndex})`;
                    itemClass = completedToday ? 'completed-multi' : '';
                } else if (completedToday) {
                    // Completed: non-clickable; undo via explicit button
                    clickHandler = 'void(0)';
                    itemClass = 'completed';
                } else if (canComplete) {
                    clickHandler = `completeActivity(${dimIndex}, ${pathIndex}, ${actIndex})`;
                    itemClass = '';
                } else {
                    clickHandler = 'void(0)';
                    itemClass = 'disabled';
                }

                const freqText = freqLabel[activity.frequency] || activity.frequency;
                const customNote = activity.frequency === 'custom' && activity.customDays ? ` (${activity.customDays}d)` : '';

                const showUndo = allowMulti
                    ? countCompletionsToday(activity) > 0
                    : completedToday;
                const undoBtn = showUndo
                    ? `<button class="btn-undo-activity" onclick="event.stopPropagation();undoActivity(${dimIndex}, ${pathIndex}, ${actIndex})" title="Undo">↩</button>`
                    : '';

                return `
                <div class="activity-item ${itemClass}" onclick="${clickHandler}">
                    <div class="activity-info-container">
                        <div class="activity-name">${escapeHtml(activity.name)}</div>
                        <div class="activity-details">
                            <span class="activity-badge badge-frequency">${freqText}${customNote}</span>
                            <span class="activity-badge ${activity.isNegative ? 'badge-negative' : 'badge-xp'}">
                                ${activity.isNegative ? '−' : '+'}${activity.baseXP} XP
                            </span>
                            ${activity.streak > 0 ? `<span class="activity-badge badge-streak">🔥 ${activity.streak}</span>` : ''}
                        </div>
                    </div>
                    <div class="dimension-actions" onclick="event.stopPropagation()">
                        ${undoBtn}
                        <div class="activity-check">✓</div>
                        <button class="btn-icon" onclick="editActivity(${dimIndex}, ${pathIndex}, ${actIndex})">Edit</button>
                        <button class="btn-icon delete" onclick="deleteActivity(${dimIndex}, ${pathIndex}, ${actIndex})">Delete</button>
                    </div>
                </div>
            `}).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Toggle Functions
        window.toggleDimension = function(dimIndex) {
            window.userData.dimensions[dimIndex].expanded = !window.userData.dimensions[dimIndex].expanded;
            renderDimensions();
        };

        window.togglePath = function(dimIndex, pathIndex) {
            window.userData.dimensions[dimIndex].paths[pathIndex].expanded =
                !window.userData.dimensions[dimIndex].paths[pathIndex].expanded;
            renderDimensions();
        };

        // Dimension Modal Functions
        let editingDimensionIndex = null;

        window.openDimensionModal = function(index = null) {
            editingDimensionIndex = index;
            const modal = document.getElementById('dimensionModal');
            const title = document.getElementById('dimensionModalTitle');
            
            if (index !== null) {
                title.textContent = 'Edit Dimension';
                const dim = window.userData.dimensions[index];
                document.getElementById('dimensionName').value = dim.name;
                document.getElementById('dimensionColor').value = dim.color || 'blue';
            } else {
                title.textContent = 'Create Dimension';
                document.getElementById('dimensionForm').reset();
            }
            
            modal.classList.add('active');
        };

        window.closeDimensionModal = function() {
            document.getElementById('dimensionModal').classList.remove('active');
            editingDimensionIndex = null;
        };

        window.saveDimension = async function(event) {
            event.preventDefault();
            
            const name = document.getElementById('dimensionName').value;
            const color = document.getElementById('dimensionColor').value;
            
            if (editingDimensionIndex !== null) {
                window.userData.dimensions[editingDimensionIndex].name = name;
                window.userData.dimensions[editingDimensionIndex].color = color;
            } else {
                window.userData.dimensions.push({
                    id: Date.now().toString(),
                    name,
                    color,
                    paths: [],
                    expanded: true,
                    createdAt: new Date().toISOString()
                });
            }
            
            await saveUserData();
            closeDimensionModal();
            updateDashboard();
        };

        window.editDimension = function(index) {
            openDimensionModal(index);
        };

        window.deleteDimension = async function(index) {
            if (confirm('Delete this dimension and all its paths/activities?')) {
                const dim = window.userData.dimensions[index];
                getActivityIdsInDimension(dim).forEach(id => cleanupChallengesForActivity(id));
                window.userData.dimensions.splice(index, 1);
                await saveUserData();
                updateDashboard();
            }
        };

        // Path Modal Functions
        let editingPathDimIndex = null;
        let editingPathIndex = null;

        window.openPathModal = function(dimIndex, pathIndex = null) {
            editingPathDimIndex = dimIndex;
            editingPathIndex = pathIndex;
            const modal = document.getElementById('pathModal');
            const title = document.getElementById('pathModalTitle');
            
            if (pathIndex !== null) {
                title.textContent = 'Edit Path';
                const path = window.userData.dimensions[dimIndex].paths[pathIndex];
                document.getElementById('pathName').value = path.name;
            } else {
                title.textContent = 'Create Path';
                document.getElementById('pathForm').reset();
            }
            
            modal.classList.add('active');
        };

        window.closePathModal = function() {
            document.getElementById('pathModal').classList.remove('active');
            editingPathDimIndex = null;
            editingPathIndex = null;
        };

        window.savePath = async function(event) {
            event.preventDefault();
            
            const name = document.getElementById('pathName').value;
            
            if (editingPathIndex !== null) {
                window.userData.dimensions[editingPathDimIndex].paths[editingPathIndex].name = name;
            } else {
                if (!window.userData.dimensions[editingPathDimIndex].paths) {
                    window.userData.dimensions[editingPathDimIndex].paths = [];
                }
                window.userData.dimensions[editingPathDimIndex].paths.push({
                    id: Date.now().toString(),
                    name,
                    activities: [],
                    expanded: true,
                    createdAt: new Date().toISOString()
                });
            }
            
            await saveUserData();
            closePathModal();
            updateDashboard();
        };

        window.editPath = function(dimIndex, pathIndex) {
            openPathModal(dimIndex, pathIndex);
        };

        window.deletePath = async function(dimIndex, pathIndex) {
            if (confirm('Delete this path and all its activities?')) {
                const path = window.userData.dimensions[dimIndex].paths[pathIndex];
                (path.activities || []).forEach(act => cleanupChallengesForActivity(act.id));
                window.userData.dimensions[dimIndex].paths.splice(pathIndex, 1);
                await saveUserData();
                updateDashboard();
            }
        };

        // Activity Modal Functions
        let editingActivityDimIndex = null;
        let editingActivityPathIndex = null;
        let editingActivityIndex = null;

        window.openActivityModal = function(dimIndex, pathIndex, actIndex = null) {
            const limitNotice = document.getElementById('activityLimitNotice');
            
            if (actIndex === null && !canAddActivity()) {
                const { total, limit } = getActivityCounts();
                const level = window.userData.level || 1;
                // Find next level that unlocks more
                let nextUnlockLevel = level + 1;
                while (getActivityLimit(nextUnlockLevel) <= limit) nextUnlockLevel++;
                document.getElementById('limitCurrent').textContent = total;
                document.getElementById('limitMax').textContent = limit;
                document.getElementById('limitNextLevel').textContent = nextUnlockLevel;
                limitNotice.style.display = 'block';
                document.querySelector('#activityForm button[type="submit"]').disabled = true;
            } else {
                limitNotice.style.display = 'none';
                document.querySelector('#activityForm button[type="submit"]').disabled = false;
            }
            
            editingActivityDimIndex = dimIndex;
            editingActivityPathIndex = pathIndex;
            editingActivityIndex = actIndex;
            const modal = document.getElementById('activityModal');
            const title = document.getElementById('activityModalTitle');
            
            if (actIndex !== null) {
                title.textContent = 'Edit Activity';
                const activity = window.userData.dimensions[dimIndex].paths[pathIndex].activities[actIndex];
                document.getElementById('activityName').value = activity.name;
                document.getElementById('activityXP').value = activity.baseXP;
                document.getElementById('activityFrequency').value = activity.frequency;
                // Negative XP fields
                const isNegEnabled = !!(activity.isNegative || activity.isSkipNegative);
                document.getElementById('activityNegativeEnabled').checked = isNegEnabled;
                document.getElementById('negativeXpSection').style.display = isNegEnabled ? 'block' : 'none';
                const mode = activity.negativeXpMode || (activity.isNegative ? 'perform' : 'skip');
                const modeEl = document.querySelector(`input[name="negativeXpMode"][value="${mode}"]`);
                if (modeEl) modeEl.checked = true;
                // Allow multiple per day
                const multiEl = document.getElementById('activityAllowMultiple');
                if (multiEl) multiEl.checked = activity.allowMultiplePerDay || false;
                document.getElementById('activityDeleteOnComplete').checked = activity.deleteOnComplete || false;
                toggleCustomDays();
                if (activity.frequency === 'custom') {
                    const sub = activity.customSubtype || 'cycle';
                    setCustomSubtypeUI(sub);
                    if (sub === 'cycle') {
                        document.getElementById('activityCustomDays').value = activity.customDays || 3;
                    } else {
                        setSelectedDays(activity.scheduledDays || []);
                    }
                    document.getElementById('activityCustomTimes').value = activity.timesPerCycle || 1;
                }
            } else {
                title.textContent = 'Create Activity';
                document.getElementById('activityForm').reset();
                document.getElementById('activityFrequency').value = 'daily'; // always reset to daily
                document.getElementById('activityNegativeEnabled').checked = false;
                document.getElementById('negativeXpSection').style.display = 'none';
                document.querySelector('input[name="negativeXpMode"][value="perform"]').checked = true;
                const grp = document.getElementById('customDaysGroup');
                if (grp) grp.style.display = 'none';
                const multiGrp = document.getElementById('allowMultipleGroup');
                if (multiGrp) multiGrp.style.display = 'none';
                toggleCustomDays(); // ensure custom days hidden
            }
            
            modal.classList.add('active');
        };

        window.toggleCustomDays = function() {
            const freq = document.getElementById('activityFrequency').value;
            const grp  = document.getElementById('customDaysGroup');
            const occGrp = document.getElementById('occasionalDeleteGroup');
            const multiGrp = document.getElementById('allowMultipleGroup');
            if (!grp) return;
            grp.style.display = (freq === 'custom') ? 'block' : 'none';
            if (occGrp) occGrp.style.display = (freq === 'occasional') ? 'block' : 'none';
            // Show "allow multiple per day" for all non-occasional frequencies
            if (multiGrp) multiGrp.style.display = (freq !== 'occasional') ? 'block' : 'none';
        };

        window.setCustomSubtype = function(type) {
            const cycleGrp   = document.getElementById('cycleSubGroup');
            const weekdayGrp = document.getElementById('weekdaySubGroup');
            const btnCycle   = document.getElementById('subtypeCycle');
            const btnDays    = document.getElementById('subtypeDays');
            if (type === 'cycle') {
                cycleGrp.style.display   = 'block';
                weekdayGrp.style.display = 'none';
                btnCycle.classList.add('active');
                btnDays.classList.remove('active');
            } else {
                cycleGrp.style.display   = 'none';
                weekdayGrp.style.display = 'block';
                btnDays.classList.add('active');
                btnCycle.classList.remove('active');
            }
        };

        window.toggleDayBtn = function(btn) {
            btn.classList.toggle('selected');
        };

        // Wire up day picker buttons
        document.querySelectorAll('.day-btn').forEach(btn => {
            btn.addEventListener('click', function() { toggleDayBtn(this); });
        });

        function getSelectedDays() {
            return [...document.querySelectorAll('.day-btn.selected')].map(b => parseInt(b.dataset.day));
        }
        function setSelectedDays(days) {
            document.querySelectorAll('.day-btn').forEach(b => {
                b.classList.toggle('selected', (days || []).includes(parseInt(b.dataset.day)));
            });
        }
        function getCustomSubtype() {
            const btn = document.getElementById('subtypeCycle');
            return (btn && btn.classList.contains('active')) ? 'cycle' : 'days';
        }
        function setCustomSubtypeUI(type) {
            setCustomSubtype(type);
        }

        window.closeActivityModal = function() {
            document.getElementById('activityModal').classList.remove('active');
            editingActivityDimIndex = null;
            editingActivityPathIndex = null;
            editingActivityIndex = null;
        };

        window.toggleNegativeXpSection = function() {
            const enabled = document.getElementById('activityNegativeEnabled').checked;
            document.getElementById('negativeXpSection').style.display = enabled ? 'block' : 'none';
        };

        window.saveActivity = async function(event) {
            event.preventDefault();
            
            const name = document.getElementById('activityName').value;
            const baseXP = parseInt(document.getElementById('activityXP').value);
            const frequency = document.getElementById('activityFrequency').value;
            const isNegativeEnabled = document.getElementById('activityNegativeEnabled').checked;
            const negativeXpMode = isNegativeEnabled
                ? (document.querySelector('input[name="negativeXpMode"]:checked')?.value || 'perform')
                : null;
            const isNegative = isNegativeEnabled && negativeXpMode === 'perform';
            const isSkipNegative = isNegativeEnabled && negativeXpMode === 'skip';
            const allowMultiplePerDay = (frequency !== 'occasional')
                ? (document.getElementById('activityAllowMultiple')?.checked || false)
                : false;
            const subtype = frequency === 'custom' ? getCustomSubtype() : null;
            const customDays = (frequency === 'custom' && subtype === 'cycle') ? Math.max(1, parseInt(document.getElementById('activityCustomDays').value) || 3) : null;
            const scheduledDays = (frequency === 'custom' && subtype === 'days') ? getSelectedDays() : null;
            const timesPerCycle = frequency === 'custom' ? Math.max(1, parseInt(document.getElementById('activityCustomTimes').value) || 1) : null;
            const deleteOnComplete = frequency === 'occasional' ? document.getElementById('activityDeleteOnComplete').checked : false;

            if (editingActivityIndex !== null) {
                const activity = window.userData.dimensions[editingActivityDimIndex]
                    .paths[editingActivityPathIndex].activities[editingActivityIndex];
                activity.name = name;
                activity.baseXP = baseXP;
                activity.frequency = frequency;
                activity.isNegative = isNegative;
                activity.isSkipNegative = isSkipNegative;
                activity.negativeXpMode = negativeXpMode;
                activity.allowMultiplePerDay = allowMultiplePerDay;
                if (frequency === 'custom') {
                    activity.customSubtype = subtype;
                    activity.customDays = customDays;
                    activity.scheduledDays = scheduledDays;
                    activity.timesPerCycle = timesPerCycle;
                } else {
                    activity.customSubtype = null;
                    activity.customDays = null;
                    activity.scheduledDays = null;
                    activity.timesPerCycle = null;
                }
                activity.deleteOnComplete = deleteOnComplete;
            } else {
                if (!canAddActivity()) {
                    alert('You\'ve reached your activity limit! Level up to unlock more.');
                    return;
                }
                
                const path = window.userData.dimensions[editingActivityDimIndex]
                    .paths[editingActivityPathIndex];
                if (!path.activities) {
                    path.activities = [];
                }
                path.activities.push({
                    id: Date.now().toString(),
                    name, baseXP, frequency, isNegative, isSkipNegative, negativeXpMode,
                    allowMultiplePerDay,
                    customSubtype: subtype,
                    customDays,
                    scheduledDays,
                    timesPerCycle,
                    deleteOnComplete,
                    streak: 0,
                    skipStreak: 0,
                    lastCompleted: null,
                    cycleCompletions: 0,
                    totalXP: 0,
                    completionCount: 0,
                    createdAt: new Date().toISOString()
                });
            }
            
            await saveUserData();
            closeActivityModal();
            updateDashboard();
        };

        window.editActivity = function(dimIndex, pathIndex, actIndex) {
            openActivityModal(dimIndex, pathIndex, actIndex);
        };

        window.deleteActivity = async function(dimIndex, pathIndex, actIndex) {
            if (confirm('Delete this activity?')) {
                const activity = window.userData.dimensions[dimIndex].paths[pathIndex].activities[actIndex];
                const actId = activity ? activity.id : null;
                window.userData.dimensions[dimIndex].paths[pathIndex].activities.splice(actIndex, 1);
                // Clean up references in challenges
                if (actId) cleanupChallengesForActivity(actId);
                await saveUserData();
                updateDashboard();
            }
        };

        // Remove a deleted activity ID from all challenges
        function cleanupChallengesForActivity(actId) {
            (window.userData.challenges || []).forEach(ch => {
                // activityIds array
                if (ch.activityIds) {
                    ch.activityIds = ch.activityIds.filter(id => id !== actId);
                }
                // activityTargets map
                if (ch.activityTargets) delete ch.activityTargets[actId];
                // activityProgress map
                if (ch.activityProgress) delete ch.activityProgress[actId];
                // Legacy single activityId
                if (ch.activityId === actId) ch.activityId = null;
                // Recalculate targetCount and currentCount
                if (ch.activityIds && ch.activityTargets) {
                    ch.targetCount = ch.activityIds.reduce((s, id) => s + (ch.activityTargets[id] || 1), 0);
                    ch.currentCount = ch.activityIds.reduce((s, id) =>
                        s + Math.min((ch.activityProgress || {})[id] || 0, ch.activityTargets[id] || 1), 0);
                }
            });
        }

        // Collect all activity IDs in a dimension for bulk cleanup
        function getActivityIdsInDimension(dim) {
            const ids = [];
            (dim.paths || []).forEach(path => {
                (path.activities || []).forEach(act => ids.push(act.id));
            });
            return ids;
        }

        // Activity Completion Functions

        // Count how many times an activity was completed today (from completionHistory)
        function countCompletionsToday(activity) {
            const todayStr = new Date().toDateString();
            return (activity.completionHistory || []).filter(
                e => new Date(e.date).toDateString() === todayStr
            ).length;
        }

        function canCompleteActivity(activity) {
            if (activity.frequency === 'custom') return canCompleteCustomToday(activity);
            // allowMultiplePerDay non-custom: always completable (no daily cap applied here;
            // streak cap is handled separately in completeActivity via streakGrantedDate)
            if (activity.allowMultiplePerDay && activity.frequency !== 'occasional') return true;
            return true;
        }

        // Return today's day-of-week index (0=Sun)
        function todayDOW() { return new Date().getDay(); }

        // For custom/days: is today one of the scheduled days?
        function isScheduledDay(activity) {
            if (!activity.scheduledDays || activity.scheduledDays.length === 0) return false;
            return activity.scheduledDays.includes(todayDOW());
        }

        // For custom activities: how many completions in the current cycle?
        function cycleCompletionsNow(activity) {
            // We track completions in the current cycle via cycleHistory array
            // Each entry: { date: ISO string }
            if (!activity.cycleHistory || activity.cycleHistory.length === 0) return 0;
            const now = new Date();
            let windowStart;
            if (activity.customSubtype === 'days') {
                // Weekly window — start of current ISO week (Monday)
                const dow = now.getDay(); // 0=Sun
                const monday = new Date(now);
                monday.setDate(now.getDate() - ((dow + 6) % 7));
                monday.setHours(0,0,0,0);
                windowStart = monday;
            } else {
                // Cycle window — starts at createdAt aligned to multiples of customDays
                const origin = new Date(activity.createdAt || activity.cycleHistory[0].date);
                origin.setHours(0,0,0,0);
                const daysSinceOrigin = Math.floor((now - origin) / 86400000);
                const cycleDays = activity.customDays || 3;
                const cycleNum = Math.floor(daysSinceOrigin / cycleDays);
                windowStart = new Date(origin.getTime() + cycleNum * cycleDays * 86400000);
            }
            return activity.cycleHistory.filter(e => new Date(e.date) >= windowStart).length;
        }

        function isCompletedToday(activity) {
            if (activity.frequency === 'custom') {
                // Fully completed if cycleCompletions >= timesPerCycle in current window
                const done = cycleCompletionsNow(activity);
                const needed = activity.timesPerCycle || 1;
                return done >= needed;
            }

            if (!activity.lastCompleted) return false;
            const lastCompleted = new Date(activity.lastCompleted);
            const today = new Date();
            const daysDiff = Math.floor((today - lastCompleted) / (1000 * 60 * 60 * 24));
            
            if (activity.frequency === 'daily') {
                return lastCompleted.toDateString() === today.toDateString();
            } else if (activity.frequency === 'occasional') {
                return lastCompleted.toDateString() === today.toDateString();
            } else if (activity.frequency === 'weekly') {
                return daysDiff < 7;
            } else if (activity.frequency === 'biweekly') {
                return daysDiff < 14;
            } else if (activity.frequency === 'monthly') {
                return daysDiff < 30;
            }
            return false;
        }

        function canCompleteCustomToday(activity) {
            if (activity.customSubtype === 'days') {
                // Must be a scheduled day
                if (!isScheduledDay(activity)) return false;
            }
            // Has remaining completions in cycle?
            const done = cycleCompletionsNow(activity);
            const needed = activity.timesPerCycle || 1;
            if (done >= needed) return false;

            // Daily limit: if allowMultiplePerDay is false (default for newly created activities),
            // only allow one completion per calendar day.
            // For backward compat: activities without allowMultiplePerDay field (old data) treat as true.
            if (activity.allowMultiplePerDay === false) {
                const today = new Date().toDateString();
                const doneToday = (activity.cycleHistory || []).filter(
                    e => new Date(e.date).toDateString() === today
                ).length;
                if (doneToday >= 1) return false;
            }
            return true;
        }

        function calculateStreak(activity) {
            if (!activity.lastCompleted) return activity.streak || 0; // preserve streak on undo
            if (activity.frequency === 'occasional') return 0; // No streak for occasional

            const lastCompleted = new Date(activity.lastCompleted);
            const today = new Date();
            const daysDiff = Math.floor((today - lastCompleted) / (1000 * 60 * 60 * 24));

            // Determine the grace window (= 1 cycle) for this frequency type.
            let graceDays;
            if (activity.frequency === 'daily') graceDays = 1;
            else if (activity.frequency === 'weekly') graceDays = 7;
            else if (activity.frequency === 'biweekly') graceDays = 14;
            else if (activity.frequency === 'monthly') graceDays = 30;
            else if (activity.frequency === 'custom') {
                graceDays = activity.customSubtype === 'days' ? 7 : (activity.customDays || 1);
            } else graceDays = 1;

            const missedCycles = daysDiff <= graceDays
                ? 0
                : Math.ceil((daysDiff - graceDays) / graceDays);

            // Negative activities (perform-mode): streak resets immediately on missing a single cycle — no shields
            if (activity.isNegative && !activity.isSkipNegative) {
                return missedCycles === 0 ? (activity.streak || 1) : 0;
            }

            // All other activities: shields auto-protect up to 3 missed cycles.
            // e.g. missing an entire week counts as 1 shield for weekly activities.
            const MAX_SHIELDS = 3;
            const usedShields = activity.streakPauseUses || 0;
            const shieldsLeft = Math.max(0, MAX_SHIELDS - usedShields);

            if (missedCycles === 0) {
                // Completed within current cycle window — streak is alive
                return activity.streak || 1;
            } else if (missedCycles <= shieldsLeft) {
                // Auto-consume one shield per missed cycle
                activity.streakPauseUses = usedShields + missedCycles;
                activity.streakPaused = false;
                return activity.streak || 1;
            } else {
                // Streak breaks — reset shields so the new streak is fully protected again
                activity.streakPauseUses = 0;
                activity.streakPaused = false;
                return 0;
            }
        }

        // Activity XP streak bonus — exponential scaling so high-streak activities
        // can yield the large amounts needed to progress through higher levels.
        // Formula: 1 + 0.1 * (streak^1.5)
        // streak 0-4: ×1.0, streak 5: ×2.1, streak 10: ×4.2, streak 20: ×9.4, streak 30: ×17.4
        function calculateConsistencyMultiplier(streak) {
            if (streak <= 0) return 1;
            if (streak < 5)  return 1;
            return +(1 + 0.1 * Math.pow(streak, 1.5)).toFixed(2);
        }

        window.completeActivity = async function(dimIndex, pathIndex, actIndex) {
            const activity = window.userData.dimensions[dimIndex].paths[pathIndex].activities[actIndex];
            
            if (!canCompleteActivity(activity)) {
                return;
            }
            // For once-per-day activities, block if already completed today
            const allowMulti = activity.allowMultiplePerDay && activity.frequency !== 'occasional';
            if (!allowMulti && isCompletedToday(activity)) {
                return;
            }

            // Reset skip streak when user performs a skip-mode activity
            if (activity.isSkipNegative && (activity.skipStreak || 0) > 0) {
                activity.skipStreak = 0;
            }
            
            const isOccasional = activity.frequency === 'occasional';
            const isCustom = activity.frequency === 'custom';
            const currentStreak = isOccasional ? 0 : calculateStreak(activity);

            // Streak incremented once per cycle — for custom, only when first completion of cycle
            const todayStr = new Date().toISOString().slice(0, 10);
            const cycleWasEmpty = isCustom ? (cycleCompletionsNow(activity) === 0) : false;
            const alreadyGrantedToday = (!isCustom && activity.streakGrantedDate === todayStr);
            const shouldGrantStreak = !isOccasional && (isCustom ? cycleWasEmpty : !alreadyGrantedToday);
            const newStreak = isOccasional ? 0 : (shouldGrantStreak ? currentStreak + 1 : currentStreak);
            if (!isOccasional && shouldGrantStreak) {
                activity.streakGrantedDate = todayStr;
            }

            const consistencyMultiplier = isOccasional ? 1 : calculateConsistencyMultiplier(newStreak);
            const earnedXP = Math.floor(activity.baseXP * consistencyMultiplier);
            
            activity.lastCompleted = new Date().toISOString();
            // Track cycle completions for custom activities
            if (isCustom) {
                if (!activity.cycleHistory) activity.cycleHistory = [];
                activity.cycleHistory.push({ date: activity.lastCompleted });
                activity.cycleCompletions = cycleCompletionsNow(activity);
            }
            if (!isOccasional) {
                activity.streak = newStreak;
                activity.bestStreak = Math.max(activity.bestStreak || 0, newStreak);
            }
            activity.completionCount = (activity.completionCount || 0) + 1;
            activity.totalXP = (activity.totalXP || 0) + earnedXP;
            recordCompletion(activity, activity.isNegative ? -earnedXP : earnedXP);
            
            // Update challenge progress
            updateChallengeProgress(activity.id);
            
            // Skip-mode activities give POSITIVE XP when performed (penalty is applied when skipped, not here)
            const xpChange = (activity.isNegative && !activity.isSkipNegative) ? -earnedXP : earnedXP;
            window.userData.currentXP += xpChange;
            window.userData.totalXP += xpChange;
            
            if (activity.isNegative && !activity.isSkipNegative) {
                // Negative habits drain XP and can level you down, but can't take you below 0 on level 1.
                // We allow level-down so the XP math is always reversible on undo.
                while (window.userData.currentXP < 0 && window.userData.level > 1) {
                    window.userData.level -= 1;
                    window.userData.currentXP += calculateXPForLevel(window.userData.level);
                }
                if (window.userData.currentXP < 0) {
                    // At level 1 and still negative — clamp, but record the actual amount deducted
                    // so undo can reverse exactly what happened.
                    activity._lastActualXpDeducted = earnedXP + window.userData.currentXP; // actual deducted (could be less than earnedXP)
                    window.userData.currentXP = 0;
                } else {
                    activity._lastActualXpDeducted = earnedXP; // full amount was deducted
                }
            } else {
                // Loop level-ups until currentXP is within the next threshold
                let leveledUp = false;
                while (window.userData.currentXP >= calculateXPForLevel(window.userData.level) && window.userData.level < 100) {
                    const threshold = calculateXPForLevel(window.userData.level);
                    window.userData.currentXP -= threshold;
                    window.userData.level += 1;
                    leveledUp = true;
                }
                // Hard cap at level 100
                if (window.userData.level >= 100) {
                    window.userData.level = 100;
                }
                if (leveledUp) {
                    await saveUserData();
                    showLevelUpAnimation();
                    updateDashboard();
                    showXPToast(xpChange, newStreak, consistencyMultiplier);
                    return;
                }
            }

            await saveUserData();
            updateDashboard();
            showXPToast(xpChange, newStreak, consistencyMultiplier);

            // Delete one-time occasional activities after completion
            if (isOccasional && activity.deleteOnComplete) {
                const dims = window.userData.dimensions;
                outer: for (let di = 0; di < dims.length; di++) {
                    for (let pi = 0; pi < dims[di].paths.length; pi++) {
                        const acts = dims[di].paths[pi].activities || [];
                        const ai = acts.findIndex(a => a.id === activity.id);
                        if (ai !== -1) { acts.splice(ai, 1); break outer; }
                    }
                }
                await saveUserData();
                updateDashboard();
            }
        };

        // Undo Activity Completion
        window.undoActivity = async function(dimIndex, pathIndex, actIndex) {
            const activity = window.userData.dimensions[dimIndex].paths[pathIndex].activities[actIndex];
            
            // Must have at least one completion today to undo
            const todayStr = new Date().toISOString().slice(0, 10);
            const hasCompletionToday = (activity.completionHistory || []).some(
                e => new Date(e.date).toISOString().slice(0, 10) === todayStr
            );
            if (!hasCompletionToday && !isCompletedToday(activity)) {
                return;
            }
            
            const isOccasional = activity.frequency === 'occasional';
            const lastStreak = activity.streak || 0;
            const consistencyMultiplier = isOccasional ? 1 : calculateConsistencyMultiplier(lastStreak);
            const earnedXP = Math.floor(activity.baseXP * consistencyMultiplier);
            const xpChange = (activity.isNegative && !activity.isSkipNegative) ? -earnedXP : earnedXP;
            
            // Remove last completionHistory entry
            if (activity.completionHistory && activity.completionHistory.length > 0) {
                activity.completionHistory.pop();
            }
            // Remove last cycleHistory entry for custom activities
            if (activity.frequency === 'custom' && activity.cycleHistory && activity.cycleHistory.length > 0) {
                activity.cycleHistory.pop();
                activity.cycleCompletions = cycleCompletionsNow(activity);
            }

            // Restore lastCompleted to the previous completion's date (or null if none left today)
            const remainingHistory = activity.completionHistory || [];
            const prevEntry = remainingHistory.length > 0 ? remainingHistory[remainingHistory.length - 1] : null;
            // Only revert lastCompleted if previous entry is from a different day or doesn't exist
            if (prevEntry) {
                activity.lastCompleted = prevEntry.date;
            } else {
                activity.lastCompleted = null;
            }

            // Revert streak grant only if the last today-completion was just removed
            const stillHasToday = remainingHistory.some(
                e => new Date(e.date).toISOString().slice(0, 10) === todayStr
            );
            if (!isOccasional && !stillHasToday && activity.streakGrantedDate === todayStr && activity.streak > 0) {
                activity.streak = Math.max(0, activity.streak - 1);
                activity.streakGrantedDate = null;
            }
            if (!isOccasional && activity.frequency === 'custom' && activity.cycleCompletions === 0 && activity.streakGrantedDate) {
                // Revert custom streak grant if no completions remain in cycle
                activity.streak = Math.max(0, activity.streak - 1);
                activity.streakGrantedDate = null;
            }

            activity.completionCount = Math.max(0, (activity.completionCount || 1) - 1);
            activity.totalXP = Math.max(0, (activity.totalXP || earnedXP) - earnedXP);
            
            // Revert XP
            let toastXP = xpChange;
            if (activity.isNegative && !activity.isSkipNegative) {
                const actualDeducted = activity._lastActualXpDeducted !== undefined ? activity._lastActualXpDeducted : earnedXP;
                delete activity._lastActualXpDeducted;
                toastXP = -actualDeducted;
                window.userData.currentXP += actualDeducted;
                window.userData.totalXP += actualDeducted;
                while (window.userData.currentXP >= calculateXPForLevel(window.userData.level) && window.userData.level < 100) {
                    window.userData.currentXP -= calculateXPForLevel(window.userData.level);
                    window.userData.level += 1;
                }
            } else {
                window.userData.currentXP -= xpChange;
                window.userData.totalXP -= xpChange;
                while (window.userData.currentXP < 0 && window.userData.level > 1) {
                    window.userData.level -= 1;
                    const restoredThreshold = calculateXPForLevel(window.userData.level);
                    window.userData.currentXP += restoredThreshold;
                }
                if (window.userData.currentXP < 0) {
                    window.userData.currentXP = 0;
                }
            }
            
            // Reverse challenge progress for this undo
            undoChallengeProgress(activity.id);

            await saveUserData();
            updateDashboard();
            showUndoToast(toastXP);
        };

        function showUndoToast(xp) {
            // xp = what was originally added (positive for positive activity, negative for negative activity)
            // undo reverses it, so message should reflect what was removed
            const isNegAct = xp < 0; // negative activity was undone → we restored XP
            _showToastPill({
                icon: '↩',
                label: isNegAct ? `+${Math.abs(xp)} XP restored` : `${Math.abs(xp)} XP removed`,
                accent: 'rgba(90,90,60,0.92)',
                accentEnd: 'rgba(122,123,77,0.92)',
                border: 'rgba(122,123,77,0.5)',
            });
        }

        function showXPToast(xp, streak, multiplier) {
            const isPos = xp > 0;
            let label = isPos ? `+${Math.abs(xp)} XP` : `−${Math.abs(xp)} XP (negative habit)`;
            let icon = isPos ? '⚡' : '💔';
            if (isPos && streak > 1) { label += `  🔥 ×${streak}`; }
            if (isPos && multiplier > 1) { label += `  (${multiplier}x)`; }
            _showToastPill({
                icon,
                label,
                accent: isPos ? 'rgba(40,80,130,0.95)' : 'rgba(110,40,70,0.95)',
                accentEnd: isPos ? 'rgba(68,114,160,0.95)' : 'rgba(142,59,95,0.95)',
                border: isPos ? 'rgba(90,159,212,0.5)' : 'rgba(194,90,115,0.5)',
            });
        }

        function _showToastPill({ icon, label, accent, border, accentEnd }) {
            // Remove any existing toast so they don't stack
            document.querySelectorAll('.xp-toast-pill').forEach(t => t.remove());

            const toast = document.createElement('div');
            toast.className = 'xp-toast-pill';
            toast.innerHTML = `
                <span style="font-size:18px;line-height:1;">${icon}</span>
                <span style="font-size:15px;font-weight:700;letter-spacing:-0.02em;">${label}</span>
            `;
            toast.style.cssText = `
                position: fixed;
                top: 88px;
                left: 50%;
                transform: translateX(-50%) translateY(-8px);
                background: linear-gradient(120deg, ${accent}, ${accentEnd || accent});
                border: 1px solid ${border};
                color: #fff;
                padding: 10px 22px;
                border-radius: 99px;
                font-family: inherit;
                display: flex;
                align-items: center;
                gap: 10px;
                z-index: 10000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.45), 0 0 0 1px ${border};
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                animation: toastSlideDown 0.3s cubic-bezier(0.34,1.56,0.64,1) forwards;
                pointer-events: none;
                white-space: nowrap;
            `;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'toastFadeUp 0.25s ease forwards';
                setTimeout(() => toast.remove(), 260);
            }, 2400);
        }

        function showLevelUpAnimation() {
            const confettiContainer = document.getElementById('confettiContainer');
            const colors = ['#4a7c9e', '#8e3b5f', '#6b7c3f', '#7a7b4d', '#5a9fd4'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 0.3 + 's';
                confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
                confetti.style.animation = 'confetti-fall ' + (Math.random() * 2 + 2) + 's ease-out forwards';
                confettiContainer.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 4000);
            }

            const newLevel = window.userData.level;
            const reward = (window.userData.rewards || {})[newLevel];

            if (reward || newLevel === 100) {
                // Show the reward overlay (or the secret L100 message)
                setTimeout(() => showRewardUnlock(newLevel), 600);
            } else {
                // Fallback: simple level-up toast
                const levelUpToast = document.createElement('div');
                levelUpToast.style.cssText = `
                    position: fixed;
                    inset: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10001;
                    pointer-events: none;
                `;
                const inner = document.createElement('div');
                inner.style.cssText = `
                    background: var(--color-accent-blue);
                    color: #fff;
                    padding: 24px 40px;
                    border-radius: 20px;
                    font-weight: 800;
                    font-size: clamp(22px, 7vw, 38px);
                    box-shadow: 0 16px 56px rgba(0,0,0,0.6);
                    animation: levelUpPop 0.45s cubic-bezier(0.34,1.56,0.64,1) both;
                    text-align: center;
                    white-space: nowrap;
                    max-width: 85vw;
                    letter-spacing: -0.02em;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 4px;
                `;
                inner.innerHTML = `<span style="font-size:clamp(30px,9vw,52px);line-height:1;">🎉</span><span>Level ${newLevel}!</span>`;
                levelUpToast.appendChild(inner);
                document.body.appendChild(levelUpToast);
                setTimeout(() => levelUpToast.remove(), 2600);
            }
        }

        // Add animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(400px);
                    opacity: 0;
                }
            }
            
            @keyframes scaleIn {
                from {
                    transform: translate(-50%, -50%) scale(0.5);
                    opacity: 0;
                }
                to {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
            }

            @keyframes levelUpPop {
                from { transform: scale(0.4); opacity: 0; }
                to   { transform: scale(1);   opacity: 1; }
            }

            @keyframes toastSlideDown {
                from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                to   { opacity: 1; transform: translateX(-50%) translateY(0); }
            }

            @keyframes toastFadeUp {
                from { opacity: 1; transform: translateX(-50%) translateY(0); }
                to   { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            }
        `;
        document.head.appendChild(style);

        // ── Rewards System ────────────────────────────────────────────────

        function renderRewards() {
            const container = document.getElementById('rewardsTimeline');
            if (!container) return;
            const data = window.userData;
            const currentLevel = data.level || 1;
            const rewards = data.rewards || {};
            const VISIBLE_FUTURE = 5;

            // Build a range: past levels that have rewards (min 2), current level, next N levels
            const levelsWithRewards = Object.keys(rewards).map(Number).filter(l => l < currentLevel && l >= 2);
            const startLevel = levelsWithRewards.length > 0 ? Math.min(...levelsWithRewards) : Math.max(2, currentLevel);
            const endLevel = Math.min(99, currentLevel + VISIBLE_FUTURE); // cap so L100 is always appended separately

            let html = '';
            const levelsToShow = new Set();
            for (let lvl = Math.max(2, startLevel); lvl <= endLevel; lvl++) levelsToShow.add(lvl);
            levelsToShow.add(100); // always show level 100
            for (const lvl of [...levelsToShow].sort((a,b) => a-b)) {
                const reward = rewards[lvl];
                const isUnlocked = lvl < currentLevel;
                const isCurrent = lvl === currentLevel;
                const nodeClass = isUnlocked ? 'unlocked' : isCurrent ? 'current' : 'future';
                const statusLabel = isUnlocked ? '✓ Unlocked' : isCurrent ? '⚡ Current Level' : `Level ${lvl}`;
                const statusBadgeClass = isUnlocked ? 'badge-unlocked' : isCurrent ? 'badge-current' : 'badge-upcoming';

                const rewardContent = reward
                    ? `<div class="reward-title">${reward.icon ? escapeHtml(reward.icon) + ' &nbsp;' : ''}${escapeHtml(reward.title)}</div>
                       ${reward.description ? `<div class="reward-desc">${escapeHtml(reward.description)}</div>` : ''}
                       <div class="reward-card-actions">
                           ${reward.link && isUnlocked ? `<a href="${escapeHtml(reward.link)}" target="_blank" rel="noopener" class="btn-reward-claim">🎁 Claim Reward</a>` : ''}
                           ${!isCurrent ? `<button class="btn-reward-edit" onclick="openRewardModal(${lvl})">✏️ Edit</button>` : ''}
                       </div>`
                    : lvl === 100
                    ? `<div class="reward-title" style="filter: blur(6px); user-select:none; pointer-events:none;">🌟 &nbsp;A secret message awaits you at Level 100!</div>
                       <div class="reward-desc" style="margin-top:6px;color:var(--color-text-secondary);font-size:12px;font-style:italic;">Reach Level 100 to reveal your reward.</div>`
                    : isCurrent
                    ? `<div class="reward-title" style="color: var(--color-text-secondary); font-style: italic; font-weight: 400;">Rewards can be set for future levels</div>`
                    : `<div class="reward-title" style="color: var(--color-text-secondary); font-style: italic; font-weight: 400;">No reward set yet</div>
                       <div class="reward-card-actions">
                           <button class="btn-reward-add" onclick="openRewardModal(${lvl})">➕ Add reward</button>
                       </div>`;

                html += `
                    <div class="reward-node ${nodeClass}">
                        <div class="reward-node-dot"></div>
                        <div class="reward-card">
                            <div class="reward-card-header">
                                <span class="reward-level-label">Level ${lvl}</span>
                                <span class="reward-status-badge ${statusBadgeClass}">${statusLabel}</span>
                            </div>
                            ${rewardContent}
                        </div>
                    </div>`;
            }
            container.innerHTML = html;
        }

        let editingRewardLevel = null;

        window.openRewardModal = function(level) {
            const currentLevel = window.userData.level || 1;
            if (level === currentLevel) return; // can't set reward for current level
            editingRewardLevel = level;
            document.getElementById('rewardModalLevel').textContent = level;
            document.getElementById('rewardModalTitle').querySelector('span').textContent = level;
            const existing = (window.userData.rewards || {})[level];
            document.getElementById('rewardTitle').value = existing ? existing.title : '';
            document.getElementById('rewardDescription').value = existing ? (existing.description || '') : '';
            document.getElementById('rewardLink').value = existing ? (existing.link || '') : '';
            document.getElementById('rewardIcon').value = existing ? (existing.icon || '') : '';
            document.getElementById('rewardModal').classList.add('active');
        };

        window.closeRewardModal = function() {
            document.getElementById('rewardModal').classList.remove('active');
            editingRewardLevel = null;
        };

        window.saveReward = async function(event) {
            event.preventDefault();
            if (editingRewardLevel === null) return;
            if (!window.userData.rewards) window.userData.rewards = {};
            window.userData.rewards[editingRewardLevel] = {
                title: document.getElementById('rewardTitle').value,
                description: document.getElementById('rewardDescription').value,
                link: document.getElementById('rewardLink').value.trim() || null,
                icon: document.getElementById('rewardIcon').value.trim() || null,
            };
            await saveUserData();
            closeRewardModal();
            renderRewards();
        };

        function showRewardUnlock(level) {
            if (level === 100) {
                document.getElementById('rewardUnlockIcon').textContent = '🌟';
                document.getElementById('rewardUnlockLevel').textContent = '🎉 Level 100 — Legendary!';
                document.getElementById('rewardUnlockTitle').textContent = 'You did it!';
                document.getElementById('rewardUnlockDesc').textContent = 'Amazing! You\'ve finally reached level 100! Settle down, breathe. And take a moment to look back at the life you\'ve created!';
                document.getElementById('rewardUnlockOverlay').style.display = 'flex';
                return;
            }
            const reward = (window.userData.rewards || {})[level];
            if (!reward) return;
            document.getElementById('rewardUnlockIcon').textContent = reward.icon || '🎁';
            document.getElementById('rewardUnlockLevel').textContent = `🎉 Level ${level} Unlocked!`;
            document.getElementById('rewardUnlockTitle').textContent = reward.title;
            document.getElementById('rewardUnlockDesc').textContent = reward.description || '';
            if (reward.link) {
                document.getElementById('rewardUnlockDesc').innerHTML += `<br><a href="${escapeHtml(reward.link)}" target="_blank" rel="noopener" style="color:var(--color-accent-blue);">🔗 Open link</a>`;
            }
            document.getElementById('rewardUnlockOverlay').style.display = 'flex';
        }

        window.dismissRewardOverlay = function() {
            document.getElementById('rewardUnlockOverlay').style.display = 'none';
        };

        // ── End Rewards System ────────────────────────────────────────────

        // ── Analytics System ──────────────────────────────────────────────

        // State
        window.analyticsState = {
            view: 'all',       // all | dimension | path | activity
            period: 'all',     // 7d | 30d | all
            dimId: null,
            pathId: null,
            activityId: null,
            chartMode: 'cumulative',  // cumulative | daily
        };
        window.calendarOffset = 0; // months relative to current
        window.xpChartInstance = null;

        // ── Helpers ──────────────────────────────────────────────────────

        function getAllActivitiesFlat() {
            const result = [];
            (window.userData.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => {
                    (path.activities || []).forEach(act => {
                        result.push({ ...act, dimId: dim.id, dimName: dim.name, pathId: path.id, pathName: path.name });
                    });
                });
            });
            return result;
        }

        function parseCompletionDates(activity) {
            // We store lastCompleted; we also need the full history.
            // Since full history isn't stored, we derive a synthetic list from completionCount + lastCompleted
            // for the calendar. Full history would require a separate log — we'll use what we have.
            const dates = [];
            if (activity.lastCompleted) dates.push(new Date(activity.lastCompleted));
            return dates;
        }

        // Build a proper completion event log from stored history arrays (if present) or fallback
        function getCompletionLog(activities) {
            const log = []; // { date, activityId, activityName, xp, dimName, pathName }
            activities.forEach(act => {
                // Use completionHistory if present (we'll start recording it going forward)
                if (act.completionHistory && act.completionHistory.length) {
                    act.completionHistory.forEach(entry => {
                        log.push({
                            date: new Date(entry.date),
                            activityId: act.id,
                            activityName: act.name,
                            xp: entry.xp || act.baseXP,
                            dimName: act.dimName,
                            pathName: act.pathName,
                        });
                    });
                } else if (act.lastCompleted) {
                    // Fallback: synthetic single entry
                    log.push({
                        date: new Date(act.lastCompleted),
                        activityId: act.id,
                        activityName: act.name,
                        xp: act.totalXP || act.baseXP,
                        dimName: act.dimName,
                        pathName: act.pathName,
                    });
                }
            });
            return log.sort((a, b) => a.date - b.date);
        }

        function filterByPeriod(log, period) {
            if (period === 'all') return log;
            const cutoff = new Date();
            if (period === '7d')  cutoff.setDate(cutoff.getDate() - 7);
            if (period === '30d') cutoff.setDate(cutoff.getDate() - 30);
            return log.filter(e => e.date >= cutoff);
        }

        function filterByScope(activities, state) {
            if (state.view === 'dimension' && state.dimId) {
                activities = activities.filter(a => a.dimId === state.dimId);
            } else if (state.view === 'path' && state.pathId) {
                activities = activities.filter(a => a.pathId === state.pathId);
            } else if (state.view === 'activity' && state.activityId) {
                activities = activities.filter(a => a.id === state.activityId);
            }
            return activities;
        }

        // ── Filter UI ─────────────────────────────────────────────────────

        window.setAnalyticsFilter = function(key, val, btn) {
            window.analyticsState[key] = val;
            // Update pill active states within parent
            const parent = btn.closest('.filter-pills');
            parent.querySelectorAll('.filter-pill').forEach(p => p.classList.remove('active'));
            btn.classList.add('active');
            // Show/hide scope dropdowns
            const view = window.analyticsState.view;
            document.getElementById('filterDimGroup').style.display    = (view === 'dimension' || view === 'path' || view === 'activity') ? 'flex' : 'none';
            document.getElementById('filterPathGroup').style.display   = (view === 'path' || view === 'activity') ? 'flex' : 'none';
            document.getElementById('filterActivityGroup').style.display = (view === 'activity') ? 'flex' : 'none';
            populateFilterDropdowns();
            renderAnalytics();
        };

        function populateFilterDropdowns() {
            const dims = window.userData.dimensions || [];
            const dimSel = document.getElementById('filterDimSelect');
            const selectedDim = window.analyticsState.dimId || (dims[0] ? dims[0].id : '');
            dimSel.innerHTML = dims.map(d => `<option value="${d.id}" ${d.id===selectedDim?'selected':''}>${escapeHtml(d.name)}</option>`).join('');
            window.analyticsState.dimId = selectedDim;

            const dim = dims.find(d => d.id === selectedDim);
            const paths = dim ? (dim.paths || []) : [];
            const pathSel = document.getElementById('filterPathSelect');
            const selectedPath = window.analyticsState.pathId || (paths[0] ? paths[0].id : '');
            pathSel.innerHTML = paths.map(p => `<option value="${p.id}" ${p.id===selectedPath?'selected':''}>${escapeHtml(p.name)}</option>`).join('');
            window.analyticsState.pathId = selectedPath;

            const path = paths.find(p => p.id === selectedPath);
            const acts = path ? (path.activities || []) : [];
            const actSel = document.getElementById('filterActivitySelect');
            const selectedAct = window.analyticsState.activityId || (acts[0] ? acts[0].id : '');
            actSel.innerHTML = acts.map(a => `<option value="${a.id}" ${a.id===selectedAct?'selected':''}>${escapeHtml(a.name)}</option>`).join('');
            window.analyticsState.activityId = selectedAct;
        }

        window.applyAnalyticsFilters = function() {
            window.analyticsState.dimId      = document.getElementById('filterDimSelect').value;
            window.analyticsState.pathId     = document.getElementById('filterPathSelect').value;
            window.analyticsState.activityId = document.getElementById('filterActivitySelect').value;
            // Re-populate path/activity when dim changes
            populateFilterDropdowns();
            renderAnalytics();
        };

        window.setChartMode = function(mode, btn) {
            window.analyticsState.chartMode = mode;
            const parent = btn.closest('.filter-pills');
            parent.querySelectorAll('.filter-pill').forEach(p => p.classList.remove('active'));
            btn.classList.add('active');
            renderXPChart(window._analyticsLog);
        };

        // ── Main Render ──────────────────────────────────────────────────

        function renderAnalytics() {
            const allActs   = getAllActivitiesFlat();
            const filtered  = filterByScope(allActs, window.analyticsState);
            const fullLog   = getCompletionLog(filtered);
            const log       = filterByPeriod(fullLog, window.analyticsState.period);
            window._analyticsLog = log;

            renderAnalyticsSummary(filtered, log);
            renderXPChart(log);
            renderXPLeaderboard(filtered, log);
            renderStreakBoard(filtered);
            renderFrequencyChart(filtered, log);
            renderCombosPanel(log);
            renderCalendar();
            renderTimeOfDay(log);
        }

        // ── Summary Cards ────────────────────────────────────────────────

        function renderAnalyticsSummary(activities, log) {
            const totalXP = activities.reduce((s, a) => s + (a.totalXP || 0), 0);
            const totalCompletions = activities.reduce((s, a) => s + (a.completionCount || 0), 0);
            const maxStreak = activities.reduce((s, a) => Math.max(s, a.streak || 0), 0);
            const activeCount = activities.filter(a => a.completionCount > 0).length;
            const el = document.getElementById('analyticsSummary');
            el.innerHTML = [
                { v: totalXP.toLocaleString(), l: 'Total XP Earned' },
                { v: totalCompletions.toLocaleString(), l: 'Completions' },
                { v: activities.length, l: 'Activities' },
                { v: activeCount, l: 'Active Activities' },
                { v: maxStreak, l: 'Best Streak' },
            ].map(s => `
                <div class="analytics-stat">
                    <div class="analytics-stat-value">${s.v}</div>
                    <div class="analytics-stat-label">${s.l}</div>
                </div>`).join('');
        }

        // ── XP Over Time Chart (pure SVG — no external lib needed) ──────

        function renderXPChart(log) {
            const container = document.querySelector('.chart-container');
            const empty = document.getElementById('xpChartEmpty');
            const canvas = document.getElementById('xpChart');

            if (!log || log.length === 0) {
                canvas.style.display = 'none';
                empty.style.display = 'flex';
                return;
            }
            empty.style.display = 'none';
            canvas.style.display = 'block';

            const mode = window.analyticsState.chartMode;
            const ctx = canvas.getContext('2d');
            const W = canvas.offsetWidth || 600;
            const H = canvas.offsetHeight || 220;
            canvas.width = W;
            canvas.height = H;

            // Build data points
            let points = [];
            if (mode === 'cumulative') {
                let cum = 0;
                log.forEach(e => {
                    cum += e.xp;
                    points.push({ date: e.date, val: cum });
                });
            } else {
                // Daily totals
                const byDay = {};
                log.forEach(e => {
                    const k = e.date.toISOString().split('T')[0];
                    byDay[k] = (byDay[k] || 0) + e.xp;
                });
                const keys = Object.keys(byDay).sort();
                keys.forEach(k => points.push({ date: new Date(k), val: byDay[k] }));
            }

            if (points.length === 0) { canvas.style.display='none'; empty.style.display='flex'; return; }

            const pad = { top: 20, right: 20, bottom: 36, left: 52 };
            const cW = W - pad.left - pad.right;
            const cH = H - pad.top - pad.bottom;

            const minDate = points[0].date.getTime();
            const maxDate = points[points.length-1].date.getTime();
            const maxVal  = Math.max(...points.map(p => p.val)) || 1;
            const dateRange = maxDate - minDate || 1;

            const px = d => pad.left + ((d.getTime() - minDate) / dateRange) * cW;
            const py = v => pad.top + cH - (v / maxVal) * cH;

            ctx.clearRect(0, 0, W, H);

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (cH / 4) * i;
                ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + cW, y); ctx.stroke();
                const label = Math.round(maxVal * (4-i) / 4);
                ctx.fillStyle = 'rgba(176,176,176,0.7)';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(label >= 1000 ? (label/1000).toFixed(1)+'k' : label, pad.left - 6, y + 4);
            }

            // Fill gradient
            const grad = ctx.createLinearGradient(0, pad.top, 0, pad.top + cH);
            grad.addColorStop(0, 'rgba(74,124,158,0.45)');
            grad.addColorStop(1, 'rgba(74,124,158,0)');
            ctx.beginPath();
            ctx.moveTo(px(points[0].date), py(points[0].val));
            points.forEach(p => ctx.lineTo(px(p.date), py(p.val)));
            ctx.lineTo(px(points[points.length-1].date), pad.top + cH);
            ctx.lineTo(px(points[0].date), pad.top + cH);
            ctx.closePath();
            ctx.fillStyle = grad;
            ctx.fill();

            // Line
            ctx.beginPath();
            ctx.moveTo(px(points[0].date), py(points[0].val));
            points.forEach(p => ctx.lineTo(px(p.date), py(p.val)));
            ctx.strokeStyle = '#5a9fd4';
            ctx.lineWidth = 2.5;
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Dots
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(px(p.date), py(p.val), 3.5, 0, Math.PI * 2);
                ctx.fillStyle = '#5a9fd4';
                ctx.fill();
            });

            // X-axis labels — smart, deduplicated, no overlap
            ctx.fillStyle = 'rgba(176,176,176,0.7)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';

            const formatDate = d => {
                const mo = d.getMonth() + 1;
                const dy = d.getDate();
                return `${mo}/${dy}`;
            };

            if (points.length === 1) {
                // Single point — just label it centered
                ctx.fillText(formatDate(points[0].date), px(points[0].date), H - 8);
            } else {
                // Pick up to 6 evenly-spaced label positions, always include first and last
                const maxLabels = Math.min(6, points.length);
                const labelIndices = new Set([0, points.length - 1]);
                if (maxLabels > 2) {
                    const step = (points.length - 1) / (maxLabels - 1);
                    for (let i = 1; i < maxLabels - 1; i++) {
                        labelIndices.add(Math.round(i * step));
                    }
                }
                const minPixelGap = 40;
                let lastLabelX = -Infinity;
                [...labelIndices].sort((a,b)=>a-b).forEach(i => {
                    const p = points[i];
                    const x = px(p.date);
                    if (x - lastLabelX >= minPixelGap) {
                        ctx.fillText(formatDate(p.date), x, H - 8);
                        lastLabelX = x;
                    }
                });
            }
        }

        // ── XP Leaderboard ───────────────────────────────────────────────

        function renderXPLeaderboard(activities, log) {
            const el = document.getElementById('xpLeaderboard');
            // Sum XP per activity from log
            const xpMap = {};
            log.forEach(e => { xpMap[e.activityId] = (xpMap[e.activityId] || 0) + e.xp; });
            // Fallback to totalXP if log is sparse
            activities.forEach(a => {
                if (!xpMap[a.id] && a.totalXP) xpMap[a.id] = a.totalXP;
            });
            const ranked = activities
                .filter(a => xpMap[a.id])
                .sort((a,b) => (xpMap[b.id]||0) - (xpMap[a.id]||0))
                .slice(0, 8);
            if (ranked.length === 0) { el.innerHTML = '<div class="empty-state" style="padding:24px 0"><p>No data yet</p></div>'; return; }
            const max = xpMap[ranked[0].id] || 1;
            const colors = ['#5a9fd4','#4a7c9e','#6b7c3f','#7a7b4d','#8e3b5f'];
            el.innerHTML = ranked.map((a, i) => `
                <div class="rank-row">
                    <span class="rank-num">#${i+1}</span>
                    <span class="rank-label" title="${escapeHtml(a.name)}">${escapeHtml(a.name)}</span>
                    <div class="rank-bar-track">
                        <div class="rank-bar-fill" style="width:${((xpMap[a.id]||0)/max*100).toFixed(1)}%;background:${colors[i%colors.length]};"></div>
                    </div>
                    <span class="rank-value">${(xpMap[a.id]||0).toLocaleString()} XP</span>
                </div>`).join('');
        }

        // ── Streak Board ─────────────────────────────────────────────────

        function renderStreakBoard(activities) {
            const el = document.getElementById('streakBoard');
            const ranked = [...activities].sort((a,b)=>(b.streak||0)-(a.streak||0)).slice(0,8);
            if (!ranked.some(a => a.streak > 0)) { el.innerHTML = '<div class="empty-state" style="padding:24px 0"><p>No streaks yet</p></div>'; return; }
            const max = ranked[0].streak || 1;
            el.innerHTML = ranked.filter(a=>a.streak>0).map((a,i) => `
                <div class="rank-row">
                    <span class="rank-num">${a.streak >= 30 ? '🔥' : a.streak >= 10 ? '⚡' : `#${i+1}`}</span>
                    <span class="rank-label" title="${escapeHtml(a.name)}">${escapeHtml(a.name)}</span>
                    <div class="rank-bar-track">
                        <div class="rank-bar-fill" style="width:${((a.streak||0)/max*100).toFixed(1)}%;background:var(--color-accent-olive);"></div>
                    </div>
                    <span class="rank-value">${a.streak} 🔥</span>
                </div>`).join('');
        }

        // ── Frequency Chart ──────────────────────────────────────────────

        function renderFrequencyChart(activities, log) {
            const el = document.getElementById('frequencyChart');
            // Only count entries in the log (completionHistory after undo removes them)
            const countMap = {};
            log.forEach(e => { countMap[e.activityId] = (countMap[e.activityId]||0) + 1; });
            // Do NOT fall back to completionCount — it can include undone completions
            const ranked = activities
                .filter(a => countMap[a.id] > 0)
                .sort((a,b) => (countMap[b.id]||0)-(countMap[a.id]||0));
            if (ranked.length === 0) { el.innerHTML = '<div class="empty-state" style="padding:24px 0"><p>No data yet</p></div>'; return; }
            const max = countMap[ranked[0].id] || 1;
            const COLORS = {most:'var(--color-accent-green)', least:'var(--color-accent-red)', mid:'var(--color-accent-blue)'};
            el.innerHTML = ranked.map((a,i) => {
                const color = i === 0 ? COLORS.most : i === ranked.length-1 ? COLORS.least : COLORS.mid;
                const tag = i === 0 ? ' 👑' : i === ranked.length-1 ? ' 🐢' : '';
                return `<div class="rank-row">
                    <span class="rank-label" style="width:130px;" title="${escapeHtml(a.name)}">${escapeHtml(a.name)}${tag}</span>
                    <div class="rank-bar-track">
                        <div class="rank-bar-fill" style="width:${((countMap[a.id]||0)/max*100).toFixed(1)}%;background:${color};"></div>
                    </div>
                    <span class="rank-value">${countMap[a.id]||0}×</span>
                </div>`;}).join('');
        }

        // ── Activity Combos ───────────────────────────────────────────────

        function renderCombosPanel(log) {
            const el = document.getElementById('combosPanel');
            // Group completions by day
            const byDay = {};
            log.forEach(e => {
                const k = e.date.toISOString().split('T')[0];
                if (!byDay[k]) byDay[k] = [];
                byDay[k].push(e.activityName);
            });
            const pairs = {};
            Object.values(byDay).forEach(names => {
                const uniq = [...new Set(names)];
                for (let i = 0; i < uniq.length; i++) {
                    for (let j = i+1; j < uniq.length; j++) {
                        const key = [uniq[i], uniq[j]].sort().join(' + ');
                        pairs[key] = (pairs[key]||0)+1;
                    }
                }
            });
            const sorted = Object.entries(pairs).sort((a,b)=>b[1]-a[1]).slice(0,6);
            if (sorted.length === 0) { el.innerHTML = '<div class="empty-state" style="padding:24px 0"><p>Complete multiple activities on the same day to see pairs</p></div>'; return; }
            el.innerHTML = sorted.map(([pair, count]) => {
                const parts = pair.split(' + ');
                return `<div class="combo-row">
                    <span class="combo-chip">${escapeHtml(parts[0])}</span>
                    <span style="font-size:12px;color:var(--color-text-secondary);">+</span>
                    <span class="combo-chip">${escapeHtml(parts[1])}</span>
                    <span class="combo-count">${count}× together</span>
                </div>`;}).join('');
        }

        // ── Calendar ─────────────────────────────────────────────────────

        window.calendarNav = function(dir) {
            window.calendarOffset += dir;
            renderCalendar();
        };

        function renderCalendar() {
            const allActs   = getAllActivitiesFlat();
            const scopeFiltered = filterByScope(allActs, window.analyticsState);

            // Populate the calendar activity dropdown
            const calSel = document.getElementById('calendarActivityFilter');
            if (calSel) {
                const currentVal = calSel.value;
                calSel.innerHTML = '<option value="">All Activities</option>' +
                    scopeFiltered.map(a => `<option value="${a.id}" ${a.id === currentVal ? 'selected' : ''}>${escapeHtml(a.name)}</option>`).join('');
            }

            // Filter by selected calendar activity
            const selectedCalId = calSel ? calSel.value : '';
            const filtered = selectedCalId
                ? scopeFiltered.filter(a => a.id === selectedCalId)
                : scopeFiltered;

            // Build day → [activities completed] map from all time (calendar ignores period filter)
            const dayMap = {};
            filtered.forEach(act => {
                if (act.completionHistory && act.completionHistory.length) {
                    act.completionHistory.forEach(e => {
                        const k = new Date(e.date).toISOString().split('T')[0];
                        if (!dayMap[k]) dayMap[k] = [];
                        dayMap[k].push({ name: act.name, xp: e.xp || act.baseXP });
                    });
                } else if (act.lastCompleted) {
                    const k = new Date(act.lastCompleted).toISOString().split('T')[0];
                    if (!dayMap[k]) dayMap[k] = [];
                    dayMap[k].push({ name: act.name, xp: act.totalXP || act.baseXP });
                }
            });

            const now = new Date();
            const target = new Date(now.getFullYear(), now.getMonth() + window.calendarOffset, 1);
            const year = target.getFullYear();
            const month = target.getMonth();

            document.getElementById('calendarMonthLabel').textContent =
                target.toLocaleString('default', { month: 'long', year: 'numeric' });

            const daysInMonth = new Date(year, month+1, 0).getDate();
            const firstDow = new Date(year, month, 1).getDay(); // 0=Sun
            const todayStr = now.toISOString().split('T')[0];

            const maxCount = Math.max(...Object.values(dayMap).map(v=>v.length), 1);

            let html = '<div class="calendar-month-grid">';
            ['Su','Mo','Tu','We','Th','Fr','Sa'].forEach(d => {
                html += `<div class="calendar-dow">${d}</div>`;
            });

            // Empty cells before first day
            for (let i = 0; i < firstDow; i++) html += '<div class="calendar-day empty"></div>';

            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
                const entries = dayMap[dateStr] || [];
                const count = entries.length;
                const isToday = dateStr === todayStr;
                const intensity = count > 0 ? 0.2 + (count / maxCount) * 0.75 : 0;
                const bg = count > 0 ? `rgba(74,124,158,${intensity.toFixed(2)})` : '';
                const tooltip = count > 0
                    ? `data-tip="${escapeHtml(entries.map(e=>e.name).join(', '))} (${count} act.)"` : '';
                html += `<div class="calendar-day ${count>0?'has-data':''} ${isToday?'today':''}"
                    style="${bg?'background:'+bg+';':''}"
                    ${tooltip}
                    onmousemove="${count>0?`showCalTip(event,'${dateStr}',${count})`:''}"
                    onmouseleave="${count>0?'hideCalTip()':''}">
                    <span style="font-size:10px;color:${count>0?'#fff':'var(--color-text-secondary)'};">${d}</span>
                </div>`;
            }
            html += '</div>';
            document.getElementById('calendarGrid').innerHTML = html;
            window._calDayMap = dayMap;
        }

        window.showCalTip = function(e, dateStr, count) {
            const tip = document.getElementById('calendarTooltip');
            const entries = (window._calDayMap || {})[dateStr] || [];
            const names = [...new Set(entries.map(e=>e.name))];
            tip.innerHTML = `<strong>${dateStr}</strong><br>${names.map(n=>'• '+escapeHtml(n)).join('<br>')}`;
            tip.style.display = 'block';
            tip.style.left = (e.clientX + 12) + 'px';
            tip.style.top  = (e.clientY - 10) + 'px';
        };

        window.hideCalTip = function() {
            document.getElementById('calendarTooltip').style.display = 'none';
        };

        // ── Time of Day ──────────────────────────────────────────────────

        function renderTimeOfDay(log) {
            const el = document.getElementById('timeOfDayChart');
            const buckets = { 'Morning (6–12)': 0, 'Afternoon (12–17)': 0, 'Evening (17–21)': 0, 'Night (21–6)': 0 };
            log.forEach(e => {
                const h = e.date.getHours();
                if (h >= 6 && h < 12)  buckets['Morning (6–12)']++;
                else if (h >= 12 && h < 17) buckets['Afternoon (12–17)']++;
                else if (h >= 17 && h < 21) buckets['Evening (17–21)']++;
                else buckets['Night (21–6)']++;
            });
            const max = Math.max(...Object.values(buckets), 1);
            const colors = ['#5a9fd4','#7a7b4d','#6b7c3f','#4a7c9e'];
            el.innerHTML = Object.entries(buckets).map(([label, count], i) => `
                <div class="tod-row">
                    <span class="tod-label">${label}</span>
                    <div class="tod-bar-track">
                        <div class="tod-bar-fill" style="width:${(count/max*100).toFixed(1)}%;background:${colors[i]};">
                            ${count > 0 ? count : ''}
                        </div>
                    </div>
                    <span class="tod-count">${count}</span>
                </div>`).join('');
        }

        // Hook into completeActivity to record completionHistory
        function recordCompletion(activity, xpEarned) {
            if (!activity.completionHistory) activity.completionHistory = [];
            activity.completionHistory.push({ date: new Date().toISOString(), xp: xpEarned });
            // Keep last 365 entries to avoid Firestore bloat
            if (activity.completionHistory.length > 365) activity.completionHistory.shift();
        }

        // ── End Analytics System ─────────────────────────────────────────

        // Save user data to Firestore
        async function saveUserData() {
            try {
                const userDocRef = doc(window.firebaseDb, 'users', window.currentUser.uid);
                await setDoc(userDocRef, window.userData);
                // Trigger daily auto-backup to Firestore (non-blocking)
                saveAutoBackup(window.userData).catch(e => console.warn('Auto-backup failed:', e.message));
            } catch (error) {
                console.error('Error saving data:', error);
                alert('Failed to save data. Please try again.');
            }
        }

        // calculateXPForLevel(L) = XP needed to advance FROM level L to level L+1.
        // Early levels are fast — players feel momentum immediately.
        // From level 6 onward, quadratic scaling (baseXP × L²) with baseXP defaulting to 30.
        // Thresholds: L1→2: 50, L2→3: 120, L3→4: 250, L4→5: 450, L5→6: 720
        // L6: 30×36=1080, L7: 1470, L8: 1920, L9: 2430, L10: 3000
        function calculateXPForLevel(level) {
            const earlyThresholds = { 1: 50, 2: 120, 3: 250, 4: 450, 5: 720 };
            if (earlyThresholds[level]) return earlyThresholds[level];
            const baseXP = window.userData.settings?.baseXP || 25;
            return Math.floor(baseXP * level * level);
        }

        // Tab switching
        window.switchTab = function(tabName) {
            window.currentTab = tabName;
            
            // Update tab buttons — find the button whose onclick matches tabName
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('onclick') === `switchTab('${tabName}')`) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');

            // Render analytics when tab is opened so charts get correct dimensions
            if (tabName === 'analytics') renderAnalytics();
        };

        window.toggleGuide = function() {
            const body = document.getElementById('guideBody');
            const btn = document.getElementById('guideToggleBtn');
            const isOpen = body.classList.toggle('open');
            btn.classList.toggle('open', isOpen);
        };

        // Settings functions
        function loadSettings() {
            const settings = window.userData.settings || { baseXP: 25, multiplier: 1.5 };
            document.getElementById("settingsBaseXP").value = settings?.baseXP || 25;
            document.getElementById('settingsMultiplier').value = settings.multiplier || 1.5;
            loadTheme();
            renderStreakPauseList();
        }

        window.saveSettings = async function() {
            const baseXP = parseInt(document.getElementById('settingsBaseXP').value);
            const multiplier = parseFloat(document.getElementById('settingsMultiplier').value);
            if (!window.userData.settings) window.userData.settings = {};
            window.userData.settings.baseXP = baseXP;
            window.userData.settings.multiplier = multiplier;
            await saveUserData();
            updateDashboard();
            showToast('✅ XP settings saved!', 'olive');
        };

        // ── Quick-Add Activity ────────────────────────────────────────────

        window.openQuickAddActivity = function() {
            const dims = window.userData.dimensions || [];
            const noDims = dims.length === 0;

            // Show dim/path selectors
            document.getElementById('activityDimPathGroup').style.display = 'block';
            document.getElementById('activityNoDimsNotice').style.display = noDims ? 'block' : 'none';

            // Populate dimension dropdown
            const dimSel = document.getElementById('activityDimSelect');
            dimSel.innerHTML = '<option value="">— select dimension —</option>' +
                dims.map(d => `<option value="${d.id}">${escapeHtml(d.name)}</option>`).join('');
            document.getElementById('activityPathSelect').innerHTML = '<option value="">— select path —</option>';

            // Set editingActivity state to null (new), but dim/path will be resolved at save time
            editingActivityDimIndex = -1; // -1 = quick-add mode
            editingActivityPathIndex = null;
            editingActivityIndex = null;

            const limitNotice = document.getElementById('activityLimitNotice');
            if (!canAddActivity()) {
                const { total, limit } = getActivityCounts();
                const level = window.userData.level || 1;
                let nextUnlockLevel = level + 1;
                while (getActivityLimit(nextUnlockLevel) <= limit) nextUnlockLevel++;
                document.getElementById('limitCurrent').textContent = total;
                document.getElementById('limitMax').textContent = limit;
                document.getElementById('limitNextLevel').textContent = nextUnlockLevel;
                limitNotice.style.display = 'block';
                document.querySelector('#activityForm button[type="submit"]').disabled = true;
            } else {
                limitNotice.style.display = 'none';
                document.querySelector('#activityForm button[type="submit"]').disabled = false;
            }
            document.getElementById('activityForm').reset();
            document.getElementById('activityFrequency').value = 'daily'; // always reset to daily
            document.getElementById('activityDimPathGroup').style.display = 'block';
            document.getElementById('activityNegativeEnabled').checked = false;
            document.getElementById('negativeXpSection').style.display = 'none';
            const _performRadio = document.querySelector('input[name="negativeXpMode"][value="perform"]');
            if (_performRadio) _performRadio.checked = true;
            if (window.toggleCustomDays) window.toggleCustomDays(); // reset custom interval visibility
            document.getElementById('activityModal').classList.add('active');
        };

        window.populateActivityPathSelect = function() {
            const dimId = document.getElementById('activityDimSelect').value;
            const dim = (window.userData.dimensions || []).find(d => d.id === dimId);
            const paths = dim ? (dim.paths || []) : [];
            document.getElementById('activityPathSelect').innerHTML =
                '<option value="">— select path —</option>' +
                paths.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
        };

        // ── Patch saveActivity to handle quick-add mode ───────────────────

        const _origSaveActivity = window.saveActivity;
        window.saveActivity = async function(event) {
            event.preventDefault();
            // Quick-add mode: resolve dim/path from dropdowns
            if (editingActivityDimIndex === -1) {
                const dimId  = document.getElementById('activityDimSelect').value;
                const pathId = document.getElementById('activityPathSelect').value;
                if (!dimId || !pathId) { alert('Please select a dimension and path.'); return; }
                const dims = window.userData.dimensions || [];
                const di = dims.findIndex(d => d.id === dimId);
                if (di === -1) { alert('Dimension not found.'); return; }
                const pi = dims[di].paths.findIndex(p => p.id === pathId);
                if (pi === -1) { alert('Path not found.'); return; }
                editingActivityDimIndex  = di;
                editingActivityPathIndex = pi;
                editingActivityIndex     = null;
            }
            // Now fall through to original logic
            const name      = document.getElementById('activityName').value;
            const baseXP    = parseInt(document.getElementById('activityXP').value);
            const frequency = document.getElementById('activityFrequency').value;
            const isNegativeEnabled = document.getElementById('activityNegativeEnabled').checked;
            const negativeXpMode = isNegativeEnabled
                ? (document.querySelector('input[name="negativeXpMode"]:checked')?.value || 'perform')
                : null;
            const isNegative = isNegativeEnabled && negativeXpMode === 'perform';
            const isSkipNegative = isNegativeEnabled && negativeXpMode === 'skip';
            const allowMultiplePerDay = (frequency !== 'occasional')
                ? (document.getElementById('activityAllowMultiple')?.checked || false)
                : false;

            const subtype = frequency === 'custom' ? getCustomSubtype() : null;
            const customDays = (frequency === 'custom' && subtype === 'cycle') ? Math.max(1, parseInt(document.getElementById('activityCustomDays').value) || 3) : null;
            const scheduledDays = (frequency === 'custom' && subtype === 'days') ? getSelectedDays() : null;
            const timesPerCycle = frequency === 'custom' ? Math.max(1, parseInt(document.getElementById('activityCustomTimes').value) || 1) : null;
            const deleteOnComplete = frequency === 'occasional' ? document.getElementById('activityDeleteOnComplete').checked : false;

            if (editingActivityIndex !== null) {
                const activity = window.userData.dimensions[editingActivityDimIndex]
                    .paths[editingActivityPathIndex].activities[editingActivityIndex];
                activity.name = name; activity.baseXP = baseXP;
                activity.frequency = frequency; activity.isNegative = isNegative;
                activity.isSkipNegative = isSkipNegative;
                activity.negativeXpMode = negativeXpMode;
                activity.allowMultiplePerDay = allowMultiplePerDay;
                if (frequency === 'custom') {
                    activity.customSubtype = subtype;
                    activity.customDays = customDays;
                    activity.scheduledDays = scheduledDays;
                    activity.timesPerCycle = timesPerCycle;
                } else {
                    activity.customSubtype = null;
                    activity.customDays = null;
                    activity.scheduledDays = null;
                    activity.timesPerCycle = null;
                }
                activity.deleteOnComplete = deleteOnComplete;
            } else {
                if (!canAddActivity()) { alert('You\'ve reached your activity limit! Level up to unlock more.'); return; }
                const path = window.userData.dimensions[editingActivityDimIndex].paths[editingActivityPathIndex];
                if (!path.activities) path.activities = [];
                path.activities.push({
                    id: Date.now().toString(), name, baseXP, frequency, isNegative, isSkipNegative, negativeXpMode,
                    allowMultiplePerDay,
                    customSubtype: subtype, customDays, scheduledDays, timesPerCycle,
                    deleteOnComplete,
                    streak: 0, lastCompleted: null, cycleCompletions: 0, totalXP: 0,
                    completionCount: 0, createdAt: new Date().toISOString()
                });
            }
            // Hide dim/path group for next open from dimensions tab
            document.getElementById('activityDimPathGroup').style.display = 'none';
            await saveUserData();
            closeActivityModal();
            updateDashboard();
        };

        // Patch closeActivityModal to hide dim/path group
        const _origCloseActivity = window.closeActivityModal;
        window.closeActivityModal = function() {
            document.getElementById('activityModal').classList.remove('active');
            document.getElementById('activityDimPathGroup').style.display = 'none';
            editingActivityDimIndex = null;
            editingActivityPathIndex = null;
            editingActivityIndex = null;
        };

        // Patch openActivityModal (dimensions tab) to keep dim/path group hidden
        const _origOpenActivity = window.openActivityModal;
        window.openActivityModal = function(dimIndex, pathIndex, actIndex = null) {
            document.getElementById('activityDimPathGroup').style.display = 'none';
            const limitNotice = document.getElementById('activityLimitNotice');
            if (actIndex === null && !canAddActivity()) {
                const { total, limit } = getActivityCounts();
                const level = window.userData.level || 1;
                let nextUnlockLevel = level + 1;
                while (getActivityLimit(nextUnlockLevel) <= limit) nextUnlockLevel++;
                document.getElementById('limitCurrent').textContent = total;
                document.getElementById('limitMax').textContent = limit;
                document.getElementById('limitNextLevel').textContent = nextUnlockLevel;
                limitNotice.style.display = 'block';
                document.querySelector('#activityForm button[type="submit"]').disabled = true;
            } else {
                limitNotice.style.display = 'none';
                document.querySelector('#activityForm button[type="submit"]').disabled = false;
            }
            editingActivityDimIndex  = dimIndex;
            editingActivityPathIndex = pathIndex;
            editingActivityIndex     = actIndex;
            const title = document.getElementById('activityModalTitle');
            if (actIndex !== null) {
                title.textContent = 'Edit Activity';
                const activity = window.userData.dimensions[dimIndex].paths[pathIndex].activities[actIndex];
                document.getElementById('activityName').value      = activity.name;
                document.getElementById('activityXP').value        = activity.baseXP;
                document.getElementById('activityFrequency').value = activity.frequency;
                // Negative XP fields
                const isNegEnabled = !!(activity.isNegative || activity.isSkipNegative);
                document.getElementById('activityNegativeEnabled').checked = isNegEnabled;
                document.getElementById('negativeXpSection').style.display = isNegEnabled ? 'block' : 'none';
                const mode = activity.negativeXpMode || (activity.isNegative ? 'perform' : 'skip');
                const modeEl = document.querySelector(`input[name="negativeXpMode"][value="${mode}"]`);
                if (modeEl) modeEl.checked = true;
                // Allow multiple per day
                const multiEl = document.getElementById('activityAllowMultiple');
                if (multiEl) multiEl.checked = activity.allowMultiplePerDay || false;
                document.getElementById('activityDeleteOnComplete').checked = activity.deleteOnComplete || false;
                if (window.toggleCustomDays) window.toggleCustomDays();
                if (activity.frequency === 'custom') {
                    const sub = activity.customSubtype || 'cycle';
                    setCustomSubtypeUI(sub);
                    if (sub === 'cycle') {
                        document.getElementById('activityCustomDays').value = activity.customDays || 3;
                    } else {
                        setSelectedDays(activity.scheduledDays || []);
                    }
                    document.getElementById('activityCustomTimes').value = activity.timesPerCycle || 1;
                }
            } else {
                title.textContent = 'Create Activity';
                document.getElementById('activityForm').reset();
                document.getElementById('activityFrequency').value = 'daily';
                document.getElementById('activityNegativeEnabled').checked = false;
                document.getElementById('negativeXpSection').style.display = 'none';
                const performRadio = document.querySelector('input[name="negativeXpMode"][value="perform"]');
                if (performRadio) performRadio.checked = true;
                const grp = document.getElementById('customDaysGroup');
                if (grp) grp.style.display = 'none';
                const multiGrp = document.getElementById('allowMultipleGroup');
                if (multiGrp) multiGrp.style.display = 'none';
                if (window.toggleCustomDays) window.toggleCustomDays();
            }
            document.getElementById('activityModal').classList.add('active');
        };

        // ── Theme Customizer ──────────────────────────────────────────────

        const THEMES = [
            { id:'default',  name:'Dark',      bg:'#181818', card:'#242424', accent:'#4472a0', progress:'#537db8' },
            { id:'midnight', name:'Midnight',  bg:'#0e0e1a', card:'#181825', accent:'#6259b8', progress:'#7870cc' },
            { id:'forest',   name:'Forest',    bg:'#111a11', card:'#192019', accent:'#3d7a46', progress:'#4e8f58' },
            { id:'crimson',  name:'Crimson',   bg:'#190e0e', card:'#231515', accent:'#8c3535', progress:'#a04545' },
            { id:'sand',     name:'Sand',      bg:'#191711', card:'#231f17', accent:'#8c7a3d', progress:'#a08f52' },
            { id:'slate',    name:'Slate',     bg:'#111520', card:'#191e2c', accent:'#4d6b9e', progress:'#637fb5' },
        ];

        function loadTheme() {
            const saved = window.userData.settings?.theme || {};
            const presets = document.getElementById('themePresets');
            if (!presets) return;
            const activeId = saved.presetId || 'default';

            presets.innerHTML = THEMES.map(t => `
                <div class="theme-swatch ${t.id === activeId ? 'active' : ''}" onclick="applyThemePreset('${t.id}', this)">
                    <div class="theme-swatch-colors">
                        <div class="theme-swatch-dot" style="background:${t.bg};border:1px solid #444;"></div>
                        <div class="theme-swatch-dot" style="background:${t.accent};"></div>
                        <div class="theme-swatch-dot" style="background:${t.progress};"></div>
                    </div>
                    <span class="theme-swatch-name">${t.name}</span>
                </div>`).join('');

            // Restore custom colors if set
            if (saved.accent)   document.getElementById('themeAccentPicker').value   = saved.accent;
            if (saved.progress) document.getElementById('themeProgressPicker').value = saved.progress;

            // Apply stored theme to CSS
            if (saved.bg)       document.documentElement.style.setProperty('--color-bg-primary',   saved.bg);
            if (saved.card)     document.documentElement.style.setProperty('--color-bg-card',       saved.card);
            if (saved.secondary) document.documentElement.style.setProperty('--color-bg-secondary', saved.secondary);
            if (saved.accent)   document.documentElement.style.setProperty('--color-accent-blue',   saved.accent);
            if (saved.progress) document.documentElement.style.setProperty('--color-progress',      saved.progress);
        }

        window.applyThemePreset = function(id, el) {
            const t = THEMES.find(x => x.id === id);
            if (!t) return;
            document.documentElement.style.setProperty('--color-bg-primary',   t.bg);
            document.documentElement.style.setProperty('--color-bg-secondary', adjustColor(t.bg, 20));
            document.documentElement.style.setProperty('--color-bg-card',      t.card);
            document.documentElement.style.setProperty('--color-accent-blue',  t.accent);
            document.documentElement.style.setProperty('--color-progress',     t.progress);
            document.getElementById('themeAccentPicker').value   = t.accent;
            document.getElementById('themeProgressPicker').value = t.progress;
            // Update swatch active state
            document.querySelectorAll('.theme-swatch').forEach(s => s.classList.remove('active'));
            if (el) el.classList.add('active');
            window._pendingTheme = { presetId: id, bg: t.bg, card: t.card,
                secondary: adjustColor(t.bg, 20), accent: t.accent, progress: t.progress };
        };

        window.previewThemeColor = function(which, value) {
            if (which === 'accent')   document.documentElement.style.setProperty('--color-accent-blue', value);
            if (which === 'progress') document.documentElement.style.setProperty('--color-progress', value);
            window._pendingTheme = window._pendingTheme || {};
            window._pendingTheme[which === 'accent' ? 'accent' : 'progress'] = value;
        };

        window.saveTheme = async function() {
            if (!window.userData.settings) window.userData.settings = {};
            window.userData.settings.theme = {
                ...(window._pendingTheme || {}),
                accent:   document.getElementById('themeAccentPicker').value,
                progress: document.getElementById('themeProgressPicker').value,
            };
            await saveUserData();
            showToast('🎨 Theme saved!', 'blue');
        };

        // Hex color brightness adjustment helper
        function adjustColor(hex, amount) {
            const num = parseInt(hex.replace('#',''), 16);
            const r = Math.min(255, ((num >> 16) & 0xff) + amount);
            const g = Math.min(255, ((num >> 8)  & 0xff) + amount);
            const b = Math.min(255, ( num        & 0xff) + amount);
            return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
        }

        // ── Streak Pause (Shield) ─────────────────────────────────────────

        function streakLabel(act) {
            const n = act.streak || 0;
            if (act.frequency === 'daily') return `🔥 ${n} day streak`;
            return `🔥 ${n} streak`;
        }

                function renderStreakPauseList() {
            const el = document.getElementById('streakPauseList');
            const sel = document.getElementById('streakPauseActivitySelect');
            if (!el || !sel) return;
            const all = [];
            (window.userData.dimensions || []).forEach(dim => {
                (dim.paths || []).forEach(path => {
                    (path.activities || []).forEach(act => {
                        // Include all streak-eligible activities: non-occasional and non-negative
                        if (act.frequency !== 'occasional' && !act.isNegative) {
                            all.push({ ...act, dimName: dim.name, pathName: path.name });
                        }
                    });
                });
            });
            // Populate select
            const currentVal = sel.value;
            sel.innerHTML = '<option value="">— Choose an activity —</option>' +
                all.map(act => `<option value="${act.id}" ${act.id === currentVal ? 'selected' : ''}>${escapeHtml(act.name)} (${act.dimName})</option>`).join('');
            // Render selected
            renderStreakPauseForSelected(all);
        }

        window.renderStreakPauseForSelected = function(allOverride) {
            const el = document.getElementById('streakPauseList');
            const sel = document.getElementById('streakPauseActivitySelect');
            if (!el || !sel) return;
            const selectedId = sel.value;
            if (!selectedId) { el.innerHTML = ''; return; }
            const all = allOverride || [];
            if (!allOverride) {
                (window.userData.dimensions || []).forEach(dim =>
                    (dim.paths || []).forEach(path =>
                        (path.activities || []).forEach(act => {
                            if (act.frequency !== 'occasional' && !act.isNegative)
                                all.push({ ...act, dimName: dim.name, pathName: path.name });
                        })));
            }
            const act = all.find(a => a.id === selectedId);
            if (!act) { el.innerHTML = ''; return; }
            const uses  = act.streakPauseUses || 0;
            const maxU  = 3;
            const isPaused = act.streakPaused;
            const dotsHtml = Array.from({length: maxU}, (_, i) =>
                `<div class="streak-use-dot ${i < uses ? 'used' : ''}"></div>`).join('');
            el.innerHTML = `
            <div class="streak-pause-item">
                <div class="streak-pause-info">
                    <div class="streak-pause-name">${escapeHtml(act.name)}</div>
                    <div class="streak-pause-meta">${escapeHtml(act.dimName)} › ${escapeHtml(act.pathName)} · ${streakLabel(act)}</div>
                </div>
                <div class="streak-pause-uses" title="${uses}/${maxU} shields used">${dotsHtml}</div>
                ${isPaused
                    ? `<span class="streak-paused-badge">Paused</span>`
                    : `<button class="btn-pause-streak" ${uses >= maxU ? 'disabled title="No shields left"' : ''} onclick="pauseStreak('${act.id}')">Use Shield</button>`
                }
            </div>
            <p class="settings-note" style="margin-top:10px;">${uses}/${maxU} shields used for this activity.</p>`;
        };

        window.pauseStreak = async function(actId) {
            let activity = null;
            (window.userData.dimensions || []).forEach(dim =>
                (dim.paths || []).forEach(path =>
                    (path.activities || []).forEach(act => { if (act.id === actId) activity = act; })));
            if (!activity) return;
            const uses = activity.streakPauseUses || 0;
            if (uses >= 3) return;
            if (!confirm(`Pause streak for "${activity.name}"? This will protect your streak for 1 day. You have ${3 - uses} shield${3 - uses !== 1 ? 's' : ''} remaining.`)) return;
            if (activity.isNegative || activity.frequency === 'occasional') return;
            activity.streakPaused = true;
            activity.streakPauseUses = uses + 1;
            activity.streakPausedAt = new Date().toISOString();
            await saveUserData();
            renderStreakPauseList();
            showToast(`🛡 Streak paused for "${activity.name}"`, 'olive');
        };

        // processStreakPauses — called on login to reset any manual pause flags.
        // Auto-shield consumption now happens live inside calculateStreak().
        function processStreakPauses() {
            const today = new Date().toISOString().split('T')[0];
            (window.userData.dimensions || []).forEach(dim =>
                (dim.paths || []).forEach(path =>
                    (path.activities || []).forEach(act => {
                        // Expire manual pause after 1 day
                        if (act.streakPaused && act.streakPausedAt) {
                            const pausedDay = act.streakPausedAt.split('T')[0];
                            if (pausedDay !== today) {
                                act.streakPaused = false;
                            }
                        }
                        // Skip-penalty: if isSkipNegative and the activity wasn't done yesterday, apply XP penalty
                        processSkipPenalty(act, today);
                    })));
        }

        // Process skip-mode negative XP: if activity was skipped yesterday, apply penalty and manage shields
        function processSkipPenalty(activity, today) {
            if (!activity.isSkipNegative) return;
            // Occasional tasks: "missed" = not completed yesterday (they reset daily, so daily miss applies)
            // All other frequencies: only apply to daily for now
            const isOccasional = activity.frequency === 'occasional' || activity.frequency === 'one-time';
            if (!isOccasional && activity.frequency !== 'daily') return;
            // Avoid double-processing on same day
            if (activity.lastSkipCheckDate === today) return;
            activity.lastSkipCheckDate = today;

            // Check if activity was completed yesterday
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yStr = yesterday.toDateString();
            const lastComp = activity.lastCompleted ? new Date(activity.lastCompleted) : null;
            const doneYesterday = lastComp && lastComp.toDateString() === yStr;

            // For occasional tasks: also check completionHistory for yesterday (since lastCompleted may lag)
            let confirmedYesterday = doneYesterday;
            if (isOccasional && !doneYesterday && activity.completionHistory) {
                confirmedYesterday = activity.completionHistory.some(e =>
                    e.date && new Date(e.date).toDateString() === yStr && (e.xp || 0) > 0
                );
            }

            if (!confirmedYesterday) {
                // Increment the skip streak (consecutive days skipped — scales the penalty)
                activity.skipStreak = (activity.skipStreak || 0) + 1;
                const skipStreak = activity.skipStreak;

                // Penalty scales with skip streak, same formula as positive XP bonus
                const penalty = Math.floor((activity.baseXP || 10) * calculateConsistencyMultiplier(skipStreak));

                // Shield logic (daily activities only — occasional don't build streaks so no shields)
                if (!isOccasional) {
                    const MAX_SHIELDS = 3;
                    const usedShields = activity.streakPauseUses || 0;
                    if (usedShields < MAX_SHIELDS) {
                        activity.streakPauseUses = usedShields + 1;
                    } else {
                        activity.streak = 0;
                        activity.streakPauseUses = 0;
                        activity.streakPaused = false;
                    }
                }

                // Apply XP penalty
                window.userData.currentXP -= penalty;
                window.userData.totalXP -= penalty;
                while (window.userData.currentXP < 0 && window.userData.level > 1) {
                    window.userData.level -= 1;
                    window.userData.currentXP += calculateXPForLevel(window.userData.level);
                }
                if (window.userData.currentXP < 0) window.userData.currentXP = 0;

                recordCompletion(activity, -penalty);
            } else {
                // Done yesterday — reset skip streak
                activity.skipStreak = 0;
            }
        }

        // ── Auto-Backup (Firestore daily checkpoint) ──────────────────────
        // Once per day, on the first save of the day, we write a snapshot of userData
        // to users/{uid}/backups/daily in Firestore. This is a secondary safety net —
        // the primary store is the main users/{uid} document.
        //
        // 💡 How it works: the backup is stored in your account's cloud database, so it
        // follows you across devices and browsers. It's overwritten once per day (the first
        // save of the day triggers it). You can restore it at any time from Settings → Data.
        // It is NOT a rolling history — only the most recent daily snapshot is kept.

        let _backupSavedDate = null; // in-memory gate so we don't re-save within a session

        async function saveAutoBackup(userData) {
            if (!window.currentUser) return;
            const today = new Date().toISOString().split('T')[0];
            if (_backupSavedDate === today) return; // already saved this session
            _backupSavedDate = today;

            const backupRef = doc(window.firebaseDb, 'users', window.currentUser.uid, 'backups', 'daily');
            await setDoc(backupRef, {
                savedAt: new Date().toISOString(),
                savedDate: today,
                data: userData
            });
            updateRestoreBackupBtn(today);
        }

        async function updateRestoreBackupBtn(knownDate) {
            const btn = document.getElementById('restoreBackupBtn');
            const metaEl = document.getElementById('restoreBackupMeta');
            if (!btn || !metaEl) return;
            try {
                let dateStr = knownDate;
                if (!dateStr && window.currentUser) {
                    const backupRef = doc(window.firebaseDb, 'users', window.currentUser.uid, 'backups', 'daily');
                    const snap = await getDoc(backupRef);
                    dateStr = snap.exists() ? snap.data().savedDate : null;
                }
                if (dateStr) {
                    metaEl.textContent = `Saved: ${dateStr}`;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                } else {
                    metaEl.textContent = 'No backup yet';
                    btn.disabled = true;
                    btn.style.opacity = '0.45';
                }
            } catch(e) {
                metaEl.textContent = 'No backup yet';
                btn.disabled = true;
                btn.style.opacity = '0.45';
            }
        }

        window.restoreAutoBackup = async function() {
            if (!window.currentUser) return;
            try {
                const backupRef = doc(window.firebaseDb, 'users', window.currentUser.uid, 'backups', 'daily');
                const snap = await getDoc(backupRef);
                if (!snap.exists()) {
                    showToast('No backup found.', 'red');
                    return;
                }
                const { savedDate, data } = snap.data();
                if (!data) { showToast('Backup is empty.', 'red'); return; }
                if (!confirm(`Restore the backup from ${savedDate}? This will replace your current data. Continue?`)) return;
                window.userData = data;
                processStreakPauses();
                await saveUserData();
                updateDashboard();
                showToast(`🔄 Data restored from ${savedDate}`, 'olive');
            } catch(e) {
                alert('Restore failed: ' + e.message);
            }
        };

        // ── Import / Export / Reset ───────────────────────────────────────

        window.exportData = function() {
            const blob = new Blob([JSON.stringify(window.userData, null, 2)], { type: 'application/json' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = `levelup-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('⬆️ Data exported!', 'green');
        };

        window.importData = async function(event) {
            const file = event.target.files[0];
            if (!file) return;
            try {
                const text = await file.text();
                const parsed = JSON.parse(text);
                // Basic validation
                if (!parsed.dimensions && !parsed.level) throw new Error('Invalid data format');
                if (!confirm('This will REPLACE all your current data with the imported file. Continue?')) {
                    event.target.value = '';
                    return;
                }
                window.userData = parsed;
                processStreakPauses();
                await saveUserData();
                updateDashboard();
                showToast('⬇️ Data imported!', 'blue');
            } catch(e) {
                alert('Failed to import: ' + e.message);
            }
            event.target.value = '';
        };

        window.confirmResetData = function() {
            const first = confirm('⚠️ This will permanently delete ALL your data — activities, XP, challenges, rewards, everything. This cannot be undone.\n\nAre you absolutely sure?');
            if (!first) return;
            const second = confirm('Last chance! Type "RESET" in the next dialog to confirm.');
            const word = prompt('Type RESET to confirm:');
            if (word !== 'RESET') { alert('Reset cancelled.'); return; }
            window.userData = {
                level: 1, currentXP: 0, totalXP: 0,
                dimensions: [], activities: [], challenges: [], rewards: {},
                settings: window.userData.settings || {},
                createdAt: new Date().toISOString()
            };
            saveUserData().then(() => { updateDashboard(); showToast('🗑️ All data cleared.', 'red'); });
        };

        // ── Generic Toast ─────────────────────────────────────────────────

        function showToast(message, color = 'blue') {
            const map = { blue:'var(--color-accent-blue)', green:'var(--color-accent-green)',
                          olive:'var(--color-accent-olive)', red:'var(--color-accent-red)' };
            const toast = document.createElement('div');
            toast.style.cssText = `position:fixed;top:100px;right:20px;background:${map[color]||map.blue};
                color:#fff;padding:14px 22px;border-radius:12px;font-weight:600;font-size:15px;
                z-index:10000;box-shadow:0 8px 24px rgba(0,0,0,0.4);animation:slideIn 0.3s ease;`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => { toast.style.animation='slideOut 0.3s ease'; setTimeout(()=>toast.remove(),300); }, 3000);
        }

        // Auth Functions
        window.switchAuthTab = function(tab) {
            const tabs = document.querySelectorAll('.auth-tab');
            const forms = document.querySelectorAll('.auth-form');
            
            tabs.forEach(t => t.classList.remove('active'));
            forms.forEach(f => f.classList.remove('active'));
            
            if (tab === 'login') {
                tabs[0].classList.add('active');
                document.getElementById('loginForm').classList.add('active');
            } else {
                tabs[1].classList.add('active');
                document.getElementById('signupForm').classList.add('active');
            }
            
            hideError();
        };

        window.handleLogin = async function(event) {
            event.preventDefault();
            hideError();
            const btn = document.getElementById('loginBtn');
            btn.disabled = true;
            btn.textContent = 'Signing in…';
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // onAuthStateChanged handles transition; keep button disabled
            } catch (error) {
                btn.disabled = false;
                btn.textContent = 'Sign In';
                showError(getErrorMessage(error.code));
            }
        };

        window.handleSignup = async function(event) {
            event.preventDefault();
            hideError();
            const btn = document.getElementById('signupBtn');
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const confirmPassword = document.getElementById('signupPasswordConfirm').value;
            if (password !== confirmPassword) {
                showError('Passwords do not match');
                return;
            }
            btn.disabled = true;
            btn.textContent = 'Creating account…';
            try {
                await createUserWithEmailAndPassword(auth, email, password);
            } catch (error) {
                btn.disabled = false;
                btn.textContent = 'Create Account';
                showError(getErrorMessage(error.code));
            }
        };

        window.handleGoogleSignIn = async function() {
            hideError();
            const btn = document.getElementById('googleBtn');
            const spinner = document.getElementById('googleSpinner');
            const icon = document.getElementById('googleIcon');
            const text = document.getElementById('googleBtnText');
            // Show loading state
            btn.disabled = true;
            spinner.style.display = 'block';
            icon.style.display = 'none';
            text.textContent = 'Signing in…';
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
                // onAuthStateChanged will handle the transition — keep spinner showing
            } catch (error) {
                // Reset button on error
                btn.disabled = false;
                spinner.style.display = 'none';
                icon.style.display = 'block';
                text.textContent = 'Continue with Google';
                showError(getErrorMessage(error.code));
            }
        };

        window.handleLogout = async function() {
            try {
                await signOut(auth);
            } catch (error) {
                console.error('Logout error:', error);
            }
        };

        // Error Handling
        function showError(message) {
            const errorDiv = document.getElementById('authError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            const errorDiv = document.getElementById('authError');
            errorDiv.style.display = 'none';
        }

        function getErrorMessage(errorCode) {
            const errorMessages = {
                'auth/email-already-in-use': 'This email is already registered',
                'auth/invalid-email': 'Invalid email address',
                'auth/operation-not-allowed': 'Operation not allowed',
                'auth/weak-password': 'Password should be at least 6 characters',
                'auth/user-disabled': 'This account has been disabled',
                'auth/user-not-found': 'No account found with this email',
                'auth/wrong-password': 'Incorrect password',
                'auth/invalid-credential': 'Invalid email or password',
                'auth/popup-closed-by-user': 'Sign-in popup was closed'
            };
            
            return errorMessages[errorCode] || 'An error occurred. Please try again.';
        }

        // Make auth available globally
        window.firebaseAuth = auth;
        window.firebaseDb = db;
    </script>
</body>
</html>
